{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TBD","title":"Home"},{"location":"1. Compilers/ABI Specification/","text":"","title":"ABI Specification"},{"location":"1. Compilers/Intro/","text":"","title":"Intro"},{"location":"1. Compilers/Linker CLI/","text":"Key Use Cases The linker Toolchain tool is called the tvm_linker and can be used in one of the following modes: Compilation . In this mode the linker compiles several modules together and provides final contract (a .tvc file) for further running using TVM. Test run . In this mode the linker runs previously prepared compiled contract using TVM emulator. This may be used to check the correctness of some smart contract parts without running them on a node. Message preparation . In this mode, the linker prepares an inbound message for a contract in the .boc format. Compilation Following command line format should be used to compile several modules together: tvm_linker compile [--debug] [--lib STDLIB ] ASM_FILE ... where: *--* (first instance) stands for the path to an assembler file; there can be several assembler files for compilation; *--* (second instance) stands for the path a to standard library assembler file (for example, stdlib_c.tvm); --debug command line option enables debug output of linking; for example, it can be used to get addresses of global symbols (for example, of functions). After the above command is executed, the linker delivers a compiled contract in the .tvc format. Test Run After assembler files are linked together, you can use the linker to run a compiled contract. This command does not start the node and has a limited usage. Mainly, test runs are used for local debugging of code parts the do not require interaction between smart contracts (e.g.: unit tests). Command line format for test run is following: tvm_linker test CONTRACT_ADDRESS [--trace] [--decode-c6] --body 00 ENTRY_ADDRESS where: *--* (instance one) stands for the address of a contract that has to be run. Note that the .tvc extension is not included; -- (instance two) stands for the contract starting point; it can be extracted from the tvm_linker compile output in --debug mode; --trace option is used to trace VM execution; each time a VM command is executed, stack and registers are printed; --decode-c6 option is used to display output actions in a friendly format. Message Creation Messages can be sent to a contract in a .boc format. These messages use contract ABI and a list of input key-value pairs. In the command line a message has the following format: tvm_linker message contract-address [--init] [-w] --abi-json json-file-with-abi --abi-method method-name --abi-params json-string-with-params where: -- (instance one) stands for the address of a target contract; note that the .tvc extension is omitted; -- (instance two) stands for the workchain ID used with the contract address; -- (instance three) stands for the path to a relevant ABI file that defines methods and their input/output parameters (see description below); -- (instance four) stands for the contract method called via the message; -- (instance five) stands for contract method parameters in JSON format (for example, {\u201ca\u201d: \u201c0x123\u201d, \u201cb\u201d : \u201c456\u201d}); ABI File Format An ABI file defines available contract methods, input parameters and outputs. ABI has a JSON-based syntax with the following structure: \u201cABI version\u201d : the version of ABI file format (should be 0 for now); \u201cfunctions\u201d : array of contract methods. Each contract method has following format: *\"name\"* - the name of a method (the method requires the *_Impl* suffix ; for example, if an ABI file has a *\u2018fn1\u2019* method, then contract should have implementation of this method entitled *\u2018fn1_Impl\u2019* ); *\u201csigned\u201d* defines whether the method is signed or not (values are \u201ctrue\" or \u201cfalse\u201d ) *\u201cinputs\u201d* contains the list of input parameters; *\u201coutputs\u201d* stands for the list of output parameters. Each method parameter has the following format: \u201cname\u201d stands for name of a parameter; \u201ctype\u201d type of a parameter ( only \u201cuint64\u201d is supported now). For example: { ABI version : 0, functions : [ { name : fn1 , signed : false , inputs : [ { name : arg1 , type : uint64 } ], outputs : [ { name : result , type : uint64 } ] } ] } More Help Use tvm_linker --help for detailed description about all options, flags and sub-commands.","title":"Linker CLI"},{"location":"1. Compilers/Linker CLI/#key-use-cases","text":"The linker Toolchain tool is called the tvm_linker and can be used in one of the following modes: Compilation . In this mode the linker compiles several modules together and provides final contract (a .tvc file) for further running using TVM. Test run . In this mode the linker runs previously prepared compiled contract using TVM emulator. This may be used to check the correctness of some smart contract parts without running them on a node. Message preparation . In this mode, the linker prepares an inbound message for a contract in the .boc format.","title":"Key Use Cases"},{"location":"1. Compilers/Linker CLI/#compilation","text":"Following command line format should be used to compile several modules together: tvm_linker compile [--debug] [--lib STDLIB ] ASM_FILE ... where: *--* (first instance) stands for the path to an assembler file; there can be several assembler files for compilation; *--* (second instance) stands for the path a to standard library assembler file (for example, stdlib_c.tvm); --debug command line option enables debug output of linking; for example, it can be used to get addresses of global symbols (for example, of functions). After the above command is executed, the linker delivers a compiled contract in the .tvc format.","title":"Compilation"},{"location":"1. Compilers/Linker CLI/#test-run","text":"After assembler files are linked together, you can use the linker to run a compiled contract. This command does not start the node and has a limited usage. Mainly, test runs are used for local debugging of code parts the do not require interaction between smart contracts (e.g.: unit tests). Command line format for test run is following: tvm_linker test CONTRACT_ADDRESS [--trace] [--decode-c6] --body 00 ENTRY_ADDRESS where: *--* (instance one) stands for the address of a contract that has to be run. Note that the .tvc extension is not included; -- (instance two) stands for the contract starting point; it can be extracted from the tvm_linker compile output in --debug mode; --trace option is used to trace VM execution; each time a VM command is executed, stack and registers are printed; --decode-c6 option is used to display output actions in a friendly format.","title":"Test Run"},{"location":"1. Compilers/Linker CLI/#message-creation","text":"Messages can be sent to a contract in a .boc format. These messages use contract ABI and a list of input key-value pairs. In the command line a message has the following format: tvm_linker message contract-address [--init] [-w] --abi-json json-file-with-abi --abi-method method-name --abi-params json-string-with-params where: -- (instance one) stands for the address of a target contract; note that the .tvc extension is omitted; -- (instance two) stands for the workchain ID used with the contract address; -- (instance three) stands for the path to a relevant ABI file that defines methods and their input/output parameters (see description below); -- (instance four) stands for the contract method called via the message; -- (instance five) stands for contract method parameters in JSON format (for example, {\u201ca\u201d: \u201c0x123\u201d, \u201cb\u201d : \u201c456\u201d});","title":"Message Creation"},{"location":"1. Compilers/Linker CLI/#abi-file-format","text":"An ABI file defines available contract methods, input parameters and outputs. ABI has a JSON-based syntax with the following structure: \u201cABI version\u201d : the version of ABI file format (should be 0 for now); \u201cfunctions\u201d : array of contract methods. Each contract method has following format: *\"name\"* - the name of a method (the method requires the *_Impl* suffix ; for example, if an ABI file has a *\u2018fn1\u2019* method, then contract should have implementation of this method entitled *\u2018fn1_Impl\u2019* ); *\u201csigned\u201d* defines whether the method is signed or not (values are \u201ctrue\" or \u201cfalse\u201d ) *\u201cinputs\u201d* contains the list of input parameters; *\u201coutputs\u201d* stands for the list of output parameters. Each method parameter has the following format: \u201cname\u201d stands for name of a parameter; \u201ctype\u201d type of a parameter ( only \u201cuint64\u201d is supported now). For example: { ABI version : 0, functions : [ { name : fn1 , signed : false , inputs : [ { name : arg1 , type : uint64 } ], outputs : [ { name : result , type : uint64 } ] } ] }","title":"ABI File Format"},{"location":"1. Compilers/Linker CLI/#more-help","text":"Use tvm_linker --help for detailed description about all options, flags and sub-commands.","title":"More Help"},{"location":"1. Compilers/LLVM/1. Compiler Highlights/","text":"","title":"1. Compiler Highlights"},{"location":"1. Compilers/LLVM/2. C Support Status/","text":"Language Features FEATURE USAGE SUPPORT STATUS COMMENTS WORKAROUNDS 6.2.1 Scopes of identifiers Define scope and visibility rules Supported by LLVM 6.2.2 Linkages of identifiers Define linkage types: external, internal, no linkage Supported but not in the default pipeline. LLVM bitcode linkage is required The linker has to support linkage of multiple translation units.The workaround is to compile each translation unit into LLVM IR: clang -S -c -O3 input1.c -emit-llvm -o input1.ll clang -S -c -O3 input2.c -emit-llvm -o input2.ll Link the IR together: llvm-link input1.ll input2.ll -o input.bc And compiling the result: clang -O3 -S -c input.bc 6.2.3 Name spaces of identifiers Define classes of identifiers with disambiguation rules Supported by LLVM 6.2.4 Storage durations of objects Define automatic, static and other lifetimes Supported by LLVM 6.2.5 Types Define types in C Integer types _Bool, char, short, int, long, long long as well as their signed and unsigned counterparts Now a workaround is implemented, proper i257 is work in progress All integers are 257 bits wide Floating point types Not supported Floating point type does not exist in the TVM. It only works with 257-bit integers. Complex types Complex numbers Not supported Complex types do not exist in the TVM. It only works with 257-bit integers. Enumerations Supported by LLVM Void type Supported by LLVM Array type Supported, see notes Dynamic arrays not supported, optimizations pending. Arrays are currently implemented as general memory (via dictionaries), but tuples are considered. Also, additional testing is needed. Structure type Supported, see notes byval mishandling is a known issue. There are two types of transfer: by value and by reference. Byval is not supported, so the workaround is to use transfer by reference. Union type Supported Function type Supported Point type Supported Qualifiers const, volatile, restrict Supported by LLVM Persistent data handling needs coverage 6.2.5.9 Representation of unsigned types Specifies that overflow is not possible for unsigned integers Not supported Unsigned integers currently work the same way signed ones do. We have more testing in the pipeline and do not recommend using coding practices and tricks that rely on overflow values. 6.2.6 Representations of types Restrict binary representation of values Supported by LLVM We use SMR for signed numbers and it is in line with the specification (6.2.6.2). It also allow representing signed numbers with more bits than its unsigned counterpart. 6.2.7 Compatible type and composite type Define value conversion rules Supported by LLVM 6.3 Conversions Define type conversion rules Supported by LLVM All the conversions are supported, but testing is still in progress 6.4 Lexical elements Define C syntax Supported by LLVM The syntax was not changed 6.5 Expressions Define rules to build an expression in C and the relevant semantics Generally supported, additional checking may be required bitwise operations on signed integers contain implementation particularities. No SMR issues expected unless Clang assumes a different representation 6.6 Constant Expressions Defines expressions that are calculated in compile time, defines the sizeof semantics The feature itself is supported by LLVM, but we supply Clang with false integer type size information. i257 activities block the feature Full support requires correct operation of sizeof work making sure that (T*)((char *)a + sizeof(*a)) is the same as a[1] 6.7 Declarations, except 6.7.8 Initialization Define how syntax and semantics of declarations (and definitions in C) Supported by LLVM 6.7.8 Initialization Defines value initialization Pending, testing in progress Issues not supporting implicit 0 initialization for static data were tested. Now it is necessary to makes sure that all initialization cases from N1256 (C99) work correctly and that the linker supports all related sections. For example, the .comm directive is not supported now. 6.8 Statements and blocks Define constructs shaping control-flow in C: loops, if, switch, goto, return, etc Supported More optimization needed. Switch is currently lowered with LLVM lowerswitch pass, native support under consideration, as well as additional control-flow optimizations 6.9 External definitions Define how external function and objects are declared in C Not supported by the Linker, workaround to be provided 6.10 Preprocessing directives #define , #include , etc Supported by LLVM J.2 Undefined behavior Limited support Tests and feedback needed TVM builtins For each core, non-stack manipulation instruction in TVM there has to be an intrinsic-based way to generate it in the compiler. A low-level library developer has to be familiar with these intrinsics. For example an LDU instruction accessible via the llvm.tvm.ldu intrinsic. Partially supported, more effort needed Limitation related to the current runtime implementation TVM annotations Denote special meaning for functions (e.g. sign check, public method, etc.) and data (e.g. persistent data) Partially supported Naming rules used instead of annotations (not optimal) Persistent data semantic Supported More optimizations needed C Standard Library FEATURE USAGE SUPPORT STATUS COMMENTS WORKAROUNDS 7.1.3 Reserved identifiers Define the list of identifiers that have to be avoided in our libraries Reserved identifiers are used 7.2 Diagnostics Defines the assert macro: a standard debugging tool used by C / C++ developers Not supported 7.4 Character handling Character operations Not supported, low priority 7.57.10 Sizes of integer types Errors A low level method for handling errors in the library and in system calls Not supported Considered for support if required to achieve compatibility with other parts of the C standard library 7.8 Format conversion of integer types Used for printing, converting to/from strings and for some auxiliary functions Not supported, low priority 7.10 Sizes of integer types Integer type size definition Not supported, but considered for implementation 7.15 Variable arguments Variable argument processing Not supported 7.16 Boolean type and values Define bool , true , false and _ _bool_true_false_are_defined Not supported, but planned to 7.17 Common definitions Define ptrdiff_t , size_t , wchar_t , NULL , offsetof Not supported 7.18 Integer types Used to define intN_t , intptr_t , and other integer types, as well as macro that set their limits Not supported Considered for implementation if proves to help serialization / deserialization 7.20 General utilities Used to define general utility items that we do not seem to need now except for the functions listed below Not supported, only partial implementation can be planned 7.20.3 Memory management functions calloc , malloc , realloc , free Not supported, high priority 7.20.4 Communication with the environment abort , exit , atexit , _Exit , getenv , system Not supported, low priority Standard C program termination mechanisms under consideration 7.20.5 Searching and sorting utilities Not supported, partially implemented and being tested 7.21 String handling Stings memory operations Not implemented, only the features below have priority 7.21.2 Copying functions memcpy, memmove, aslo its string conterparts. Implemented partially in the runtime, needs to be moved to the std lib 7.21.4 Comparison functions memcmp Not implemented 7.21.6 Miscellaneous functions memset Implemented as a part of the runtime, need to be moved to the std lib 7.23 Date and time Not implemented C for TVM Numbers in the Feature column indicate references to the TON TVM specification. Please, refer to the original document. FEATURE USAGE SUPPORT STATUS COMMENTS TVM types Partially implemented Only integers are supported Operations with cells (A.7) Slice, Builder, Dictionary, Message, External Internal addresses, etc. Partially implemented in the runtime Standard node operations involve data types specified in Assembly instructions. These Assembly instructions are converted into C equivalents at some point of the optimization process Operations with dictionaries (A.10) #include cell.h Limited implementation in the runtime A low level library that is implemented via cell intrinsics to provide developer-friendly cell handling options. GAS related logic (A.11.2) Functions to buy gas for Grams and vice versa, defines gas limits Not implemented Same as above for dictionaries Operations with time (A.11.4) Current time, time of the current block and transaction Not implemented Hashing and cryptography (A.11.5) Not implemented Currency manipulation (A.11.6) Loads and stores Grams Partial implementation Message serialization Implemented Message deserialization Implemented Outbound message and output action (A.11.8) Partially implemented Sending messages available Debug support (A.12) Partially implemented For more details on available debugging options, navigate to the Debugging options topic. Events emitting Not implemented Planned Convenience FEATURE USAGE SUPPORT STATUS NOTES SUGGESTIONS Toolchain support in the driver: the driver should use our std lib headers (or don't use it at all) instead of using the system ones Not implemented Planned Toolchain support in the driver: default pipeline is to be available clang -O3 input.c should produce a .boc file (or return a compilation error) Not implemented Planned","title":"Language Features"},{"location":"1. Compilers/LLVM/2. C Support Status/#language-features","text":"FEATURE USAGE SUPPORT STATUS COMMENTS WORKAROUNDS 6.2.1 Scopes of identifiers Define scope and visibility rules Supported by LLVM 6.2.2 Linkages of identifiers Define linkage types: external, internal, no linkage Supported but not in the default pipeline. LLVM bitcode linkage is required The linker has to support linkage of multiple translation units.The workaround is to compile each translation unit into LLVM IR: clang -S -c -O3 input1.c -emit-llvm -o input1.ll clang -S -c -O3 input2.c -emit-llvm -o input2.ll Link the IR together: llvm-link input1.ll input2.ll -o input.bc And compiling the result: clang -O3 -S -c input.bc 6.2.3 Name spaces of identifiers Define classes of identifiers with disambiguation rules Supported by LLVM 6.2.4 Storage durations of objects Define automatic, static and other lifetimes Supported by LLVM 6.2.5 Types Define types in C Integer types _Bool, char, short, int, long, long long as well as their signed and unsigned counterparts Now a workaround is implemented, proper i257 is work in progress All integers are 257 bits wide Floating point types Not supported Floating point type does not exist in the TVM. It only works with 257-bit integers. Complex types Complex numbers Not supported Complex types do not exist in the TVM. It only works with 257-bit integers. Enumerations Supported by LLVM Void type Supported by LLVM Array type Supported, see notes Dynamic arrays not supported, optimizations pending. Arrays are currently implemented as general memory (via dictionaries), but tuples are considered. Also, additional testing is needed. Structure type Supported, see notes byval mishandling is a known issue. There are two types of transfer: by value and by reference. Byval is not supported, so the workaround is to use transfer by reference. Union type Supported Function type Supported Point type Supported Qualifiers const, volatile, restrict Supported by LLVM Persistent data handling needs coverage 6.2.5.9 Representation of unsigned types Specifies that overflow is not possible for unsigned integers Not supported Unsigned integers currently work the same way signed ones do. We have more testing in the pipeline and do not recommend using coding practices and tricks that rely on overflow values. 6.2.6 Representations of types Restrict binary representation of values Supported by LLVM We use SMR for signed numbers and it is in line with the specification (6.2.6.2). It also allow representing signed numbers with more bits than its unsigned counterpart. 6.2.7 Compatible type and composite type Define value conversion rules Supported by LLVM 6.3 Conversions Define type conversion rules Supported by LLVM All the conversions are supported, but testing is still in progress 6.4 Lexical elements Define C syntax Supported by LLVM The syntax was not changed 6.5 Expressions Define rules to build an expression in C and the relevant semantics Generally supported, additional checking may be required bitwise operations on signed integers contain implementation particularities. No SMR issues expected unless Clang assumes a different representation 6.6 Constant Expressions Defines expressions that are calculated in compile time, defines the sizeof semantics The feature itself is supported by LLVM, but we supply Clang with false integer type size information. i257 activities block the feature Full support requires correct operation of sizeof work making sure that (T*)((char *)a + sizeof(*a)) is the same as a[1] 6.7 Declarations, except 6.7.8 Initialization Define how syntax and semantics of declarations (and definitions in C) Supported by LLVM 6.7.8 Initialization Defines value initialization Pending, testing in progress Issues not supporting implicit 0 initialization for static data were tested. Now it is necessary to makes sure that all initialization cases from N1256 (C99) work correctly and that the linker supports all related sections. For example, the .comm directive is not supported now. 6.8 Statements and blocks Define constructs shaping control-flow in C: loops, if, switch, goto, return, etc Supported More optimization needed. Switch is currently lowered with LLVM lowerswitch pass, native support under consideration, as well as additional control-flow optimizations 6.9 External definitions Define how external function and objects are declared in C Not supported by the Linker, workaround to be provided 6.10 Preprocessing directives #define , #include , etc Supported by LLVM J.2 Undefined behavior Limited support Tests and feedback needed TVM builtins For each core, non-stack manipulation instruction in TVM there has to be an intrinsic-based way to generate it in the compiler. A low-level library developer has to be familiar with these intrinsics. For example an LDU instruction accessible via the llvm.tvm.ldu intrinsic. Partially supported, more effort needed Limitation related to the current runtime implementation TVM annotations Denote special meaning for functions (e.g. sign check, public method, etc.) and data (e.g. persistent data) Partially supported Naming rules used instead of annotations (not optimal) Persistent data semantic Supported More optimizations needed","title":"Language Features"},{"location":"1. Compilers/LLVM/2. C Support Status/#c-standard-library","text":"FEATURE USAGE SUPPORT STATUS COMMENTS WORKAROUNDS 7.1.3 Reserved identifiers Define the list of identifiers that have to be avoided in our libraries Reserved identifiers are used 7.2 Diagnostics Defines the assert macro: a standard debugging tool used by C / C++ developers Not supported 7.4 Character handling Character operations Not supported, low priority 7.57.10 Sizes of integer types Errors A low level method for handling errors in the library and in system calls Not supported Considered for support if required to achieve compatibility with other parts of the C standard library 7.8 Format conversion of integer types Used for printing, converting to/from strings and for some auxiliary functions Not supported, low priority 7.10 Sizes of integer types Integer type size definition Not supported, but considered for implementation 7.15 Variable arguments Variable argument processing Not supported 7.16 Boolean type and values Define bool , true , false and _ _bool_true_false_are_defined Not supported, but planned to 7.17 Common definitions Define ptrdiff_t , size_t , wchar_t , NULL , offsetof Not supported 7.18 Integer types Used to define intN_t , intptr_t , and other integer types, as well as macro that set their limits Not supported Considered for implementation if proves to help serialization / deserialization 7.20 General utilities Used to define general utility items that we do not seem to need now except for the functions listed below Not supported, only partial implementation can be planned 7.20.3 Memory management functions calloc , malloc , realloc , free Not supported, high priority 7.20.4 Communication with the environment abort , exit , atexit , _Exit , getenv , system Not supported, low priority Standard C program termination mechanisms under consideration 7.20.5 Searching and sorting utilities Not supported, partially implemented and being tested 7.21 String handling Stings memory operations Not implemented, only the features below have priority 7.21.2 Copying functions memcpy, memmove, aslo its string conterparts. Implemented partially in the runtime, needs to be moved to the std lib 7.21.4 Comparison functions memcmp Not implemented 7.21.6 Miscellaneous functions memset Implemented as a part of the runtime, need to be moved to the std lib 7.23 Date and time Not implemented","title":"C Standard Library"},{"location":"1. Compilers/LLVM/2. C Support Status/#c-for-tvm","text":"Numbers in the Feature column indicate references to the TON TVM specification. Please, refer to the original document. FEATURE USAGE SUPPORT STATUS COMMENTS TVM types Partially implemented Only integers are supported Operations with cells (A.7) Slice, Builder, Dictionary, Message, External Internal addresses, etc. Partially implemented in the runtime Standard node operations involve data types specified in Assembly instructions. These Assembly instructions are converted into C equivalents at some point of the optimization process Operations with dictionaries (A.10) #include cell.h Limited implementation in the runtime A low level library that is implemented via cell intrinsics to provide developer-friendly cell handling options. GAS related logic (A.11.2) Functions to buy gas for Grams and vice versa, defines gas limits Not implemented Same as above for dictionaries Operations with time (A.11.4) Current time, time of the current block and transaction Not implemented Hashing and cryptography (A.11.5) Not implemented Currency manipulation (A.11.6) Loads and stores Grams Partial implementation Message serialization Implemented Message deserialization Implemented Outbound message and output action (A.11.8) Partially implemented Sending messages available Debug support (A.12) Partially implemented For more details on available debugging options, navigate to the Debugging options topic. Events emitting Not implemented Planned","title":"C for TVM"},{"location":"1. Compilers/LLVM/2. C Support Status/#convenience","text":"FEATURE USAGE SUPPORT STATUS NOTES SUGGESTIONS Toolchain support in the driver: the driver should use our std lib headers (or don't use it at all) instead of using the system ones Not implemented Planned Toolchain support in the driver: default pipeline is to be available clang -O3 input.c should produce a .boc file (or return a compilation error) Not implemented Planned","title":"Convenience"},{"location":"1. Compilers/LLVM/3. C to TVM Library/","text":"","title":"3. C to TVM Library"},{"location":"1. Compilers/LLVM/4. Debugging Options/","text":"Analyze Test For the time being, there is not way to analyze contract return values: the contract sends external messages, and the instrument which can parse them is yet to be developed. Still, there are two ways to visualize contract execution results: peeking into persistent memory and transferring funds to other accounts. For the issues below, we consider that you already sent all messages to contracts and now are analyzing new state of the blockchain. Persistent Memory This method requires your contract to write values into persistent memory. Open a terminal window. Change your directory to /build_contract_ .c . Start test-lite-client: test-lite-client -\u0421 ton-global.json. Use the getaccount 0: command to retrieve the contact data (expect a long list of values). Find the ' data: ' string. It contains raw contents of the persistent memory specified after the string. Close the terminal when finished. Transferring Funds This method requires your contract to send funds to another account. Open a new terminal window. Change your directory to project-name /build_contract_ contract-name .c Start test-lite-client: **test-lite-client -\u0421 ton-global.json.** Use the **getaccount** **0: another account address** command to retrieve the contact data (expect a long list of values). Find **storage/balance/grams/amount** field (it is close to the top of the account info) and check its value. Close the terminal when finished.","title":"4. Debugging Options"},{"location":"1. Compilers/LLVM/4. Debugging Options/#analyze-test","text":"For the time being, there is not way to analyze contract return values: the contract sends external messages, and the instrument which can parse them is yet to be developed. Still, there are two ways to visualize contract execution results: peeking into persistent memory and transferring funds to other accounts. For the issues below, we consider that you already sent all messages to contracts and now are analyzing new state of the blockchain.","title":"Analyze &amp; Test"},{"location":"1. Compilers/LLVM/4. Debugging Options/#persistent-memory","text":"This method requires your contract to write values into persistent memory. Open a terminal window. Change your directory to /build_contract_ .c . Start test-lite-client: test-lite-client -\u0421 ton-global.json. Use the getaccount 0: command to retrieve the contact data (expect a long list of values). Find the ' data: ' string. It contains raw contents of the persistent memory specified after the string. Close the terminal when finished.","title":"Persistent Memory"},{"location":"1. Compilers/LLVM/4. Debugging Options/#transferring-funds","text":"This method requires your contract to send funds to another account. Open a new terminal window. Change your directory to project-name /build_contract_ contract-name .c Start test-lite-client: **test-lite-client -\u0421 ton-global.json.** Use the **getaccount** **0: another account address** command to retrieve the contact data (expect a long list of values). Find **storage/balance/grams/amount** field (it is close to the top of the account info) and check its value. Close the terminal when finished.","title":"Transferring Funds"},{"location":"1. Compilers/Solidity/1. Support status/","text":"","title":"1. Support status"},{"location":"1. Compilers/Solidity/2. Reference Guide/","text":"","title":"2. Reference Guide"},{"location":"1. Compilers/Solidity/3. Usage/","text":"","title":"3. Usage"},{"location":"2. SDK/1. Installation/","text":"Preparation Prerequisites Install the latest version of Docker . See installation tips in the screenshots below: For Linux users, make sure that you are able to run docker as non-root user (see https://docs.docker.com/install/linux/linux-postinstall/ ); Tip : check this page for more Docker installation options https://phoenixnap.com/kb/how-to-install-docker-on-ubuntu-18-04 . Install Node.js 10.x or newer. Make sure that Docker daemon is running on your computer. To check its status, call docker ps . Note that it is recommended to have at least 2Gb of RAM to use Node SE efficiently. Basic Installation This is the easiest version. You can only call three commands to install the solution. First, install TON Labs CLI by running: npm install -g ton-dev-cli Important : If you get errors related to permissions when trying to install packages globally, you can try to fix them using the following options: https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally . Or call: sudo chown -R $(whoami) $(npm root -g) If you fail, run the command under sudo . Then setup your machine. The step is optional, because tondev start and tondev sol perform the step on demand (see below). tondev setup Run the Local Node Call the following command to run the local node instance (Node SE): tondev start Manual Installation If you have troubles with tondev CLI utility you can install all required components yourself with the following commands: Note that Windows and Linux use different slashes ( / vs. * * ) for system paths. Make sure to change them as needed in the paths to avoid errors. docker pull tonlabs/local-node docker pull tonlabs/compilers docker create -e USER_AGREEMENT=yes --name tonlabs-local-node -i -p80:80 tonlabs/local-node mkdir user home directory /.tonlabs/compilers/projects docker create -e USER_AGREEMENT=yes --name tonlabs-compilers -it --mount type=bind,dst=/projects,src= user home directory /.tonlabs/compilers/projects tonlabs/compilers docker start tonlabs-local-node docker start tonlabs-compilers Home directory may have one of the following formats: Windows: C:\\Users\\User1 MacOS: '/Users/johnDough' Linux: /home/johnDough \u200b Install Client Libraries Tip : go to the Getting Started section, to create your own environment and a test project from scratch according to detailed guidelines. Rust Add a dependency into your cargo manifest: [dependencies] ton-client-rs = 0.11.1 Call the following command: cargo update Node.js Call the following command to install Node.js client library (the recommended version comes first): dependencies : { ton-client-node-js : ^0.12.1 } Then execute (in the project folder): ~/ton-dev/hello$ npm install Or instead of steps 1 and 2 call: npm install ton-client-node-js Web Call the following command to install client library for web browsers: npm install ton-client-web-js React Native Call the following command to install client library for React Native: npm install ton-client-react-native-js Visit TON Dev for additional product, company community info.","title":"1. Installation"},{"location":"2. SDK/1. Installation/#preparation","text":"","title":"Preparation"},{"location":"2. SDK/1. Installation/#prerequisites","text":"Install the latest version of Docker . See installation tips in the screenshots below: For Linux users, make sure that you are able to run docker as non-root user (see https://docs.docker.com/install/linux/linux-postinstall/ ); Tip : check this page for more Docker installation options https://phoenixnap.com/kb/how-to-install-docker-on-ubuntu-18-04 . Install Node.js 10.x or newer. Make sure that Docker daemon is running on your computer. To check its status, call docker ps . Note that it is recommended to have at least 2Gb of RAM to use Node SE efficiently.","title":"Prerequisites"},{"location":"2. SDK/1. Installation/#basic-installation","text":"This is the easiest version. You can only call three commands to install the solution. First, install TON Labs CLI by running: npm install -g ton-dev-cli Important : If you get errors related to permissions when trying to install packages globally, you can try to fix them using the following options: https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally . Or call: sudo chown -R $(whoami) $(npm root -g) If you fail, run the command under sudo . Then setup your machine. The step is optional, because tondev start and tondev sol perform the step on demand (see below). tondev setup","title":"Basic Installation"},{"location":"2. SDK/1. Installation/#run-the-local-node","text":"Call the following command to run the local node instance (Node SE): tondev start","title":"Run the Local Node"},{"location":"2. SDK/1. Installation/#manual-installation","text":"If you have troubles with tondev CLI utility you can install all required components yourself with the following commands: Note that Windows and Linux use different slashes ( / vs. * * ) for system paths. Make sure to change them as needed in the paths to avoid errors. docker pull tonlabs/local-node docker pull tonlabs/compilers docker create -e USER_AGREEMENT=yes --name tonlabs-local-node -i -p80:80 tonlabs/local-node mkdir user home directory /.tonlabs/compilers/projects docker create -e USER_AGREEMENT=yes --name tonlabs-compilers -it --mount type=bind,dst=/projects,src= user home directory /.tonlabs/compilers/projects tonlabs/compilers docker start tonlabs-local-node docker start tonlabs-compilers Home directory may have one of the following formats: Windows: C:\\Users\\User1 MacOS: '/Users/johnDough' Linux: /home/johnDough \u200b","title":"Manual Installation"},{"location":"2. SDK/1. Installation/#install-client-libraries","text":"Tip : go to the Getting Started section, to create your own environment and a test project from scratch according to detailed guidelines.","title":"Install Client Libraries"},{"location":"2. SDK/1. Installation/#rust","text":"Add a dependency into your cargo manifest: [dependencies] ton-client-rs = 0.11.1 Call the following command: cargo update","title":"Rust"},{"location":"2. SDK/1. Installation/#nodejs","text":"Call the following command to install Node.js client library (the recommended version comes first): dependencies : { ton-client-node-js : ^0.12.1 } Then execute (in the project folder): ~/ton-dev/hello$ npm install Or instead of steps 1 and 2 call: npm install ton-client-node-js","title":"Node.js"},{"location":"2. SDK/1. Installation/#web","text":"Call the following command to install client library for web browsers: npm install ton-client-web-js","title":"Web"},{"location":"2. SDK/1. Installation/#react-native","text":"Call the following command to install client library for React Native: npm install ton-client-react-native-js Visit TON Dev for additional product, company community info.","title":"React Native"},{"location":"2. SDK/2. Overview/","text":"Accessible Toolkit TON Labs SDK comes with tools and features helping TON Dev developers to: Compile smart contracts into the TVC format See the Toolchain documentation for detailed information about TON Labs compilers. For additional information on the TVC format, refer to the original TON blockchain documentation. Deploy, run, test and debug smart contracts using a local Node Server (Node SE) Quickly and easily interact with blockchain data and track changes Components TON Labs Local Node \u2013 Debug and test your smart contracts in a controlled environment with an instance that acts just like a production node. TON Labs Compiler Kit \u2013 Compile TVC files from Solidity source code and from C using our LLVM-based solution. TON Labs Client Libraries \u2013 An open standard to develop smart contract and test them locally. TON Dev CLI that glues the components together and enables smooth installation and development. Each TON Labs Client Library includes: Crypto \u2013 TON-related cryptography functions. Contracts - smart contract deployment and management. Queries \u2013 monitoring and querying blockchain data in real time. Prerequisites To use the product, you need a machine that supports Docker . All the necessary docker images are available at docker hub. You also have to install one of the newest stable versions of Node.js. Any supported development/runtime environment can run TON Labs Client Libraries installed with the proper package manager. Warning : Docker utilizes a built-in virtual machine management component called Hyper-V to run itself. It is not a feature of Windows Home edition. Therefore, the solution cannot be installed on Windows Home Edition. All the other Windows editions fit the required criteria. Tip : If you are a Windows Home user, try installing a VM according to the doc here . Sources You can use the installation procedure provided in the this guide to smoothly create your own development lab, but, in case you are interested, here are the links to sources: https://github.com/tonlabs/ton-client-node-js https://github.com/tonlabs/ton-client-web-js https://github.com/tonlabs/ton-client-react-native-js https://github.com/tonlabs/ton-client-rs https://hub.docker.com/r/tonlabs/local-node https://hub.docker.com/r/tonlabs/compilers Visit TON Dev for additional product, company community info.","title":"2. Overview"},{"location":"2. SDK/2. Overview/#accessible-toolkit","text":"TON Labs SDK comes with tools and features helping TON Dev developers to: Compile smart contracts into the TVC format See the Toolchain documentation for detailed information about TON Labs compilers. For additional information on the TVC format, refer to the original TON blockchain documentation. Deploy, run, test and debug smart contracts using a local Node Server (Node SE) Quickly and easily interact with blockchain data and track changes","title":"Accessible Toolkit"},{"location":"2. SDK/2. Overview/#components","text":"TON Labs Local Node \u2013 Debug and test your smart contracts in a controlled environment with an instance that acts just like a production node. TON Labs Compiler Kit \u2013 Compile TVC files from Solidity source code and from C using our LLVM-based solution. TON Labs Client Libraries \u2013 An open standard to develop smart contract and test them locally. TON Dev CLI that glues the components together and enables smooth installation and development. Each TON Labs Client Library includes: Crypto \u2013 TON-related cryptography functions. Contracts - smart contract deployment and management. Queries \u2013 monitoring and querying blockchain data in real time.","title":"Components"},{"location":"2. SDK/2. Overview/#prerequisites","text":"To use the product, you need a machine that supports Docker . All the necessary docker images are available at docker hub. You also have to install one of the newest stable versions of Node.js. Any supported development/runtime environment can run TON Labs Client Libraries installed with the proper package manager. Warning : Docker utilizes a built-in virtual machine management component called Hyper-V to run itself. It is not a feature of Windows Home edition. Therefore, the solution cannot be installed on Windows Home Edition. All the other Windows editions fit the required criteria. Tip : If you are a Windows Home user, try installing a VM according to the doc here .","title":"Prerequisites"},{"location":"2. SDK/2. Overview/#sources","text":"You can use the installation procedure provided in the this guide to smoothly create your own development lab, but, in case you are interested, here are the links to sources: https://github.com/tonlabs/ton-client-node-js https://github.com/tonlabs/ton-client-web-js https://github.com/tonlabs/ton-client-react-native-js https://github.com/tonlabs/ton-client-rs https://hub.docker.com/r/tonlabs/local-node https://hub.docker.com/r/tonlabs/compilers Visit TON Dev for additional product, company community info.","title":"Sources"},{"location":"2. SDK/Auxiliaries/Getting Logs/","text":"To review logs, call the following command providing the relevant container name or id: docker exec -it container_name_or_id bash The log is then displayed in the terminal. The log file is stored at cd /ton-node/log in output.log . You can also copy it directly to host by calling: docker cp container :/ton-node/log/output.log dest_path The screenshot shows log of the local node performance. Note that the use of sudo depends on your local settings and preferences. It is not necessary or mandatory.","title":"Getting Logs"},{"location":"2. SDK/Auxiliaries/Installing Ubuntu VM/","text":"Accessible Toolkit TON Labs SDK comes with tools and features helping TON Dev developers to: Compile smart contracts into the TVC format See the Toolchain documentation for detailed information about TON Labs compilers. For additional information on the TVC format, refer to the original TON blockchain documentation. Deploy, run, test and debug smart contracts using a local Node Server (Node SE) Quickly and easily interact with blockchain data and track changes Components TON Labs Local Node \u2013 Debug and test your smart contracts in a controlled environment with an instance that acts just like a production node. TON Labs Compiler Kit \u2013 Compile TVC files from Solidity source code and from C using our LLVM-based solution. TON Labs Client Libraries \u2013 An open standard to develop smart contract and test them locally. TON Dev CLI that glues the components together and enables smooth installation and development. Each TON Labs Client Library includes: Crypto \u2013 TON-related cryptography functions. Contracts - smart contract deployment and management. Queries \u2013 monitoring and querying blockchain data in real time. Prerequisites To use the product, you need a machine that supports Docker . All the necessary docker images are available at docker hub. You also have to install one of the newest stable versions of Node.js. Any supported development/runtime environment can run TON Labs Client Libraries installed with the proper package manager. Warning : Docker utilizes a built-in virtual machine management component called Hyper-V to run itself. It is not a feature of Windows Home edition. Therefore, the solution cannot be installed on Windows Home Edition. All the other Windows editions fit the required criteria. Tip : If you are a Windows Home user, try installing a VM according to the doc here . Sources You can use the installation procedure provided in the this guide to smoothly create your own development lab, but, in case you are interested, here are the links to sources: https://github.com/tonlabs/ton-client-node-js https://github.com/tonlabs/ton-client-web-js https://github.com/tonlabs/ton-client-react-native-js https://github.com/tonlabs/ton-client-rs https://hub.docker.com/r/tonlabs/local-node https://hub.docker.com/r/tonlabs/compilers Visit TON Dev for additional product, company community info.","title":"Installing Ubuntu VM"},{"location":"2. SDK/Auxiliaries/Installing Ubuntu VM/#accessible-toolkit","text":"TON Labs SDK comes with tools and features helping TON Dev developers to: Compile smart contracts into the TVC format See the Toolchain documentation for detailed information about TON Labs compilers. For additional information on the TVC format, refer to the original TON blockchain documentation. Deploy, run, test and debug smart contracts using a local Node Server (Node SE) Quickly and easily interact with blockchain data and track changes","title":"Accessible Toolkit"},{"location":"2. SDK/Auxiliaries/Installing Ubuntu VM/#components","text":"TON Labs Local Node \u2013 Debug and test your smart contracts in a controlled environment with an instance that acts just like a production node. TON Labs Compiler Kit \u2013 Compile TVC files from Solidity source code and from C using our LLVM-based solution. TON Labs Client Libraries \u2013 An open standard to develop smart contract and test them locally. TON Dev CLI that glues the components together and enables smooth installation and development. Each TON Labs Client Library includes: Crypto \u2013 TON-related cryptography functions. Contracts - smart contract deployment and management. Queries \u2013 monitoring and querying blockchain data in real time.","title":"Components"},{"location":"2. SDK/Auxiliaries/Installing Ubuntu VM/#prerequisites","text":"To use the product, you need a machine that supports Docker . All the necessary docker images are available at docker hub. You also have to install one of the newest stable versions of Node.js. Any supported development/runtime environment can run TON Labs Client Libraries installed with the proper package manager. Warning : Docker utilizes a built-in virtual machine management component called Hyper-V to run itself. It is not a feature of Windows Home edition. Therefore, the solution cannot be installed on Windows Home Edition. All the other Windows editions fit the required criteria. Tip : If you are a Windows Home user, try installing a VM according to the doc here .","title":"Prerequisites"},{"location":"2. SDK/Auxiliaries/Installing Ubuntu VM/#sources","text":"You can use the installation procedure provided in the this guide to smoothly create your own development lab, but, in case you are interested, here are the links to sources: https://github.com/tonlabs/ton-client-node-js https://github.com/tonlabs/ton-client-web-js https://github.com/tonlabs/ton-client-react-native-js https://github.com/tonlabs/ton-client-rs https://hub.docker.com/r/tonlabs/local-node https://hub.docker.com/r/tonlabs/compilers Visit TON Dev for additional product, company community info.","title":"Sources"},{"location":"2. SDK/Auxiliaries/TON SDK CLI/","text":"Install and Run To install, call: npm install -g ton-dev-cli To run, call: tondev command ...args Key \u0421ommands help : displays the complete list of available commands; setup : installs all required TON Labs software and start services; start : starts Node SE and Compiler containers; sol files [ -l js ] : build the contract .tvc and .abi.json files from Solidity files Optionally you can generate a JavaScript file with contract ABI and TVC encoded with base64 tondev setup tondev sol filename tondev sol filename -l js clean : stops and removes all containers and images related to Node SE and its components; info gets the current Node SE state. The command shows: the list of images and docker containers related to Node SE. current container state list of versions available at docker hub. container settings the version in use use version : allows switching between containers, e.g.: tondev use 0.11.0 . By default :latest is used. restart restarts the containers; recreate used to recreate containers; When called without parameters, tondev is similar to the info command. \u200b Reference List Usage: tondev [options] [command] TON Labs development tools Options: -V, --version output the version number -a, --available show available versions -h, --help output usage information Commands: info [options] Show summary about dev environment setup [options] Setup dev environment start [options] Start dev containers stop [options] Stop dev containers restart [options] Restart dev containers recreate [options] Recreate dev containers clean [options] Remove docker containers and images related to TON Dev use [options] version Use specified version for containers set [options] [network...] Set network[s] options add [network...] Add network[s] remove|rm [network...] Remove network[s] sol [options] [files...] Build solidity contract[s] -------------- Commands help: -------------- Command: info Usage: tondev info [options] Show summary about dev environment Options: Visit TON Dev for additional product, company community info.","title":"TON SDK CLI"},{"location":"2. SDK/Auxiliaries/TON SDK CLI/#install-and-run","text":"To install, call: npm install -g ton-dev-cli To run, call: tondev command ...args","title":"Install and Run"},{"location":"2. SDK/Auxiliaries/TON SDK CLI/#key-ommands","text":"help : displays the complete list of available commands; setup : installs all required TON Labs software and start services; start : starts Node SE and Compiler containers; sol files [ -l js ] : build the contract .tvc and .abi.json files from Solidity files Optionally you can generate a JavaScript file with contract ABI and TVC encoded with base64 tondev setup tondev sol filename tondev sol filename -l js clean : stops and removes all containers and images related to Node SE and its components; info gets the current Node SE state. The command shows: the list of images and docker containers related to Node SE. current container state list of versions available at docker hub. container settings the version in use use version : allows switching between containers, e.g.: tondev use 0.11.0 . By default :latest is used. restart restarts the containers; recreate used to recreate containers; When called without parameters, tondev is similar to the info command. \u200b","title":"Key \u0421ommands"},{"location":"2. SDK/Auxiliaries/TON SDK CLI/#reference-list","text":"Usage: tondev [options] [command] TON Labs development tools Options: -V, --version output the version number -a, --available show available versions -h, --help output usage information Commands: info [options] Show summary about dev environment setup [options] Setup dev environment start [options] Start dev containers stop [options] Stop dev containers restart [options] Restart dev containers recreate [options] Recreate dev containers clean [options] Remove docker containers and images related to TON Dev use [options] version Use specified version for containers set [options] [network...] Set network[s] options add [network...] Add network[s] remove|rm [network...] Remove network[s] sol [options] [files...] Build solidity contract[s] -------------- Commands help: -------------- Command: info Usage: tondev info [options] Show summary about dev environment Options: Visit TON Dev for additional product, company community info.","title":"Reference List"},{"location":"2. SDK/Auxiliaries/Troubleshooting/","text":"Accessible Toolkit TON Labs SDK comes with tools and features helping TON Dev developers to: Compile smart contracts into the TVC format See the Toolchain documentation for detailed information about TON Labs compilers. For additional information on the TVC format, refer to the original TON blockchain documentation. Deploy, run, test and debug smart contracts using a local Node Server (Node SE) Quickly and easily interact with blockchain data and track changes Components TON Labs Local Node \u2013 Debug and test your smart contracts in a controlled environment with an instance that acts just like a production node. TON Labs Compiler Kit \u2013 Compile TVC files from Solidity source code and from C using our LLVM-based solution. TON Labs Client Libraries \u2013 An open standard to develop smart contract and test them locally. TON Dev CLI that glues the components together and enables smooth installation and development. Each TON Labs Client Library includes: Crypto \u2013 TON-related cryptography functions. Contracts - smart contract deployment and management. Queries \u2013 monitoring and querying blockchain data in real time. Prerequisites To use the product, you need a machine that supports Docker . All the necessary docker images are available at docker hub. You also have to install one of the newest stable versions of Node.js. Any supported development/runtime environment can run TON Labs Client Libraries installed with the proper package manager. Warning : Docker utilizes a built-in virtual machine management component called Hyper-V to run itself. It is not a feature of Windows Home edition. Therefore, the solution cannot be installed on Windows Home Edition. All the other Windows editions fit the required criteria. Tip : If you are a Windows Home user, try installing a VM according to the doc here . Sources You can use the installation procedure provided in the this guide to smoothly create your own development lab, but, in case you are interested, here are the links to sources: https://github.com/tonlabs/ton-client-node-js https://github.com/tonlabs/ton-client-web-js https://github.com/tonlabs/ton-client-react-native-js https://github.com/tonlabs/ton-client-rs https://hub.docker.com/r/tonlabs/local-node https://hub.docker.com/r/tonlabs/compilers Visit TON Dev for additional product, company community info.","title":"Troubleshooting"},{"location":"2. SDK/Auxiliaries/Troubleshooting/#accessible-toolkit","text":"TON Labs SDK comes with tools and features helping TON Dev developers to: Compile smart contracts into the TVC format See the Toolchain documentation for detailed information about TON Labs compilers. For additional information on the TVC format, refer to the original TON blockchain documentation. Deploy, run, test and debug smart contracts using a local Node Server (Node SE) Quickly and easily interact with blockchain data and track changes","title":"Accessible Toolkit"},{"location":"2. SDK/Auxiliaries/Troubleshooting/#components","text":"TON Labs Local Node \u2013 Debug and test your smart contracts in a controlled environment with an instance that acts just like a production node. TON Labs Compiler Kit \u2013 Compile TVC files from Solidity source code and from C using our LLVM-based solution. TON Labs Client Libraries \u2013 An open standard to develop smart contract and test them locally. TON Dev CLI that glues the components together and enables smooth installation and development. Each TON Labs Client Library includes: Crypto \u2013 TON-related cryptography functions. Contracts - smart contract deployment and management. Queries \u2013 monitoring and querying blockchain data in real time.","title":"Components"},{"location":"2. SDK/Auxiliaries/Troubleshooting/#prerequisites","text":"To use the product, you need a machine that supports Docker . All the necessary docker images are available at docker hub. You also have to install one of the newest stable versions of Node.js. Any supported development/runtime environment can run TON Labs Client Libraries installed with the proper package manager. Warning : Docker utilizes a built-in virtual machine management component called Hyper-V to run itself. It is not a feature of Windows Home edition. Therefore, the solution cannot be installed on Windows Home Edition. All the other Windows editions fit the required criteria. Tip : If you are a Windows Home user, try installing a VM according to the doc here .","title":"Prerequisites"},{"location":"2. SDK/Auxiliaries/Troubleshooting/#sources","text":"You can use the installation procedure provided in the this guide to smoothly create your own development lab, but, in case you are interested, here are the links to sources: https://github.com/tonlabs/ton-client-node-js https://github.com/tonlabs/ton-client-web-js https://github.com/tonlabs/ton-client-react-native-js https://github.com/tonlabs/ton-client-rs https://hub.docker.com/r/tonlabs/local-node https://hub.docker.com/r/tonlabs/compilers Visit TON Dev for additional product, company community info.","title":"Sources"},{"location":"2. SDK/Client Libraries/Library Modules/1. Contracts/","text":"About the ABI Despite the fact that each TON contract is actually a single function, the TON SDK allows defining multiple functions within it. To achieve it, the original multi-functional contract is compiled into a single function one with an incoming message dispatcher. For correct encoding incoming messages to these contracts and decoding output ones, the SDK Library uses an ABI: a structural description of input/output messages related to contract functions. Compiling to TVC With the SDK compiler you can: obtain TVM-ready code from Solidity sources. obtain TVM-ready code from our LLVM-based compiler that can potentially take source code in various general purpose languages. Now we have an implementation of the C language. The Toolchain documentation contains all information on TON Labs Toolchain. The Compiler Kit is shipped as a Docker container with pre-configured tools ready to work. Deploying contracts The Contracts module of the TON Labs Client Library allows you to deploy a compiled contract to the blockchain. To deploy a contract, you need TVM-ready code ( .tvc file), an ABI ( .abi.json file) and a key pair. Note : a contract cannot be deployed before it has some amount of Grams on its balance. All attempts to deploy a contract with a zero balance will fail. So, before deploying a contract, run another one to transfer Grams to the contract you plan to deploy. Make sure that the transferred amount covers all deployment fees and costs. Or, in case you are using Node SE instance, use the pre-deployed Giver for it. Add this code to your index.js file: const nodeSeGiverAddress = 'a46af093b38fcae390e9af5104a93e22e82c29bcb35bf88160e4478417028884'; const nodeSeGiverAbi = { ABI version : 1, functions : [ { name : constructor , inputs : [ ], outputs : [ ] }, { name : sendGrams , inputs : [ { name : dest , type : uint256 }, { name : amount , type : uint64 } ], outputs : [ ] } ], events : [ ], data : [ ] }; async function get_grams_from_giver(client, account) { const { contracts, queries } = client; const result = await contracts.run({ address: giverAddress, functionName: 'sendGrams', abi: giverAbi, input: { dest: `0x${account}`, amount: 10000000000 }, keyPair: null, }); const wait = await queries.accounts.waitFor( { id: { eq: account }, storage: { balance: { Grams: { gt: 0 } } } }, 'id storage {balance {Grams}}' ); }; Now you need to calculate future address by generating deploy message of the contract to know where to transfer funds for deploy. const futureHelloAddress = (await client.contracts.createDeployMessage({ package: HelloContract.package, constructorParams: {}, keyPair: helloKeys, })).address; console.log(`Future address of the contract will be: ${futureHelloAddress}`); Transfer some grams to this address: await get_grams_from_giver(client, futureHelloAddress); console.log(`Grams were transfered from giver to ${futureHelloAddress}`); Now you are ready to initialize the account with contract code by deploying it. Run const helloAddress = (await client.contracts.deploy({ package: HelloContract.package, constructorParams: {}, keyPair: helloKeys, })).address; console.log(`Hello contract was deployed at address: ${helloAddress}`); The package parameter is a structure with two fields: abi and imageBase64 , where: abi is a contract ABI; imageBase64 is the TVC code encoded with base64. The contructorParams includes parameters passed to the constructor. It can be empty and expressed as {} , if the constructor has no parameters. The keyPair is a mandatory parameter that specifies the following: public key is placed into contract initial state as a rule for deploying ABI-based contracts; secret key is used to sign a constructor invocation. The deployment method executes the following sequence: Prepares a deploy request. Sends a constructor message to a node Waits until the deployment is complete. Generates the constructor invocation request. Sends the invocation to the blockchain node. Waits until the invocation phase is complete. The returned result contains an account address assigned to the newly deployed contract. Running contracts Running functions Running a contract implies the following steps: Generating an input message to contract with a function name and parameter values. Posting this message to the node. Waiting until the node runs the contract at the TVM, recording the result into blockchain and synchronizing the changes with TON. Reading an output message with function result from the blockchain and decoding it. In the SDK all these steps are incorporated within the run library method. To run a contract, we need its address, an ABI, a function name with parameters and a key pair if message signing is required. const resut = await client.contracts.run({ address: helloAddress, abi: HelloContract.package.abi, functionName: 'sayHello', input: {}, keyPair: helloKeys, }); The result contains the output field with a decoded output message returned by the source contract function. If an optional keyPair parameter is specified, the input message is signed and accompanied with a public key. So, the contract can perform authorization using a verifiable public key passed to it. Running locally Cases are when all a contract function does is calculate some data based on the current contract state and return the calculation result. In these cases we do not need the standard sequence to run a contract. Instead, the following steps are taken: Generate an input message to contract with a function name and parameter values. Read the current contract state into an application. The contract state is taken from ArangoDB. Run the contract code on a lightweight TVM included into the client library by passing a contract state and an input message. Decode the contract output message. This running method is less time-consuming and involves no fees related to a regular contract execution. Note : local contract invocation does not impact the blockchain: all transactions, message and state change produces are just discarded. To execute a contract inside an application just use the runLocal method instead of run . The parameters are the same, only the method name differs. const localResponse = await client.contracts.runLocal({ address: helloAddress, abi: HelloContract.package.abi, functionName: 'sayHello', input: {}, keyPair: helloKeys, }); Decoding messages Some contract functions can generate output messages targeted at some external services. Mainly, these are integration services designed as a glue between blockchain contracts and regular REST (or similar) services. Typically, these services use the following scenario: The service subscribes to messages changes in a blockchain. Usually a subscription is filtered by messages related to a specific account. When a new message comes to a blockchain, an integration service is triggered. It reads and decodes this message. Then, the integration service invokes an offchain service using parameters according to the decoded data. For these services the Client library provides the decodeOutputMessage method. It decodes output messages recorded into a blockchain. In addition to decoding output messages the Client library provides the decodeInputMessage method that decodes input messages. Note : Decoding requires an ABI and is only applicable to ABI compliant messages. Advanced Features Advanced Features Signing messages externally Although the library provides friendly and simple functions to deploy and run contracts, there are cases when more precision and control is required to deploy and run an application contract. For example, an application can use a crypto provider inaccessible from the client library (e.g. a JavaCard crypto provider). To solve this, the library offers several functions: createUnsignedDeployRequest and createUnsignedRunRequest \u2013 these functions take the same parameters as the deploy or run functions except that instead of keyPair only the public key is passed. This function returns an encoded message body and a byte buffer required to produce a signature. createSignedDeployMessage and createSignedRunMessage \u2013 this functions take an unsigned message body, sign bytes and the public key. The output is a message compatible with a blockchain node. createDeployMessage and createRunMessage \u2013 these functions generate the same sequence. The example below shows how to create an unsigned deploy message, sign it and then combine the unsigned message with the signature and finally to deploy the signed message. async function testExternalSigning(client) { const { contracts, crypto } = client; // Generate Key Pair const masterKeys = await crypto.ed25519Keypair(); // Prepare deploy params and use only public key const deployParams = { package: events_package, constructorParams: {}, keyPair: { public: masterKeys.public, secret: '' }, }; // Create unsigned deploy message const unsignedMessage = await contracts.createUnsignedDeployMessage(deployParams); const bytesToSignBase64 = unsignedMessage.signParams.bytesToSignBase64; // Create signature for bytes buffer // This can be done in isolated secret place like a HSM const signBytesBase64 = await crypto.naclSignDetached( { base64: bytesToSignBase64 }, `${masterKeys.secret}${masterKeys.public}`, TONOutputEncoding.Base64 ); // Create signed message with provided sign const signed = await contracts.createSignedDeployMessage({ address: unsignedMessage.address, createSignedParams: { publicKeyHex: masterKeys.public, signBytesBase64: signBytesBase64, unsignedBytesBase64: unsignedMessage.signParams.unsignedBytesBase64, } }); // Deploy signed message const message = await contracts.createDeployMessage(deployParams); expect(signed.message.messageBodyBase64).toEqual(message.message.messageBodyBase64); }","title":"1. Contracts"},{"location":"2. SDK/Client Libraries/Library Modules/1. Contracts/#about-the-abi","text":"Despite the fact that each TON contract is actually a single function, the TON SDK allows defining multiple functions within it. To achieve it, the original multi-functional contract is compiled into a single function one with an incoming message dispatcher. For correct encoding incoming messages to these contracts and decoding output ones, the SDK Library uses an ABI: a structural description of input/output messages related to contract functions.","title":"About the ABI"},{"location":"2. SDK/Client Libraries/Library Modules/1. Contracts/#compiling-to-tvc","text":"With the SDK compiler you can: obtain TVM-ready code from Solidity sources. obtain TVM-ready code from our LLVM-based compiler that can potentially take source code in various general purpose languages. Now we have an implementation of the C language. The Toolchain documentation contains all information on TON Labs Toolchain. The Compiler Kit is shipped as a Docker container with pre-configured tools ready to work.","title":"Compiling to TVC"},{"location":"2. SDK/Client Libraries/Library Modules/1. Contracts/#deploying-contracts","text":"The Contracts module of the TON Labs Client Library allows you to deploy a compiled contract to the blockchain. To deploy a contract, you need TVM-ready code ( .tvc file), an ABI ( .abi.json file) and a key pair. Note : a contract cannot be deployed before it has some amount of Grams on its balance. All attempts to deploy a contract with a zero balance will fail. So, before deploying a contract, run another one to transfer Grams to the contract you plan to deploy. Make sure that the transferred amount covers all deployment fees and costs. Or, in case you are using Node SE instance, use the pre-deployed Giver for it. Add this code to your index.js file: const nodeSeGiverAddress = 'a46af093b38fcae390e9af5104a93e22e82c29bcb35bf88160e4478417028884'; const nodeSeGiverAbi = { ABI version : 1, functions : [ { name : constructor , inputs : [ ], outputs : [ ] }, { name : sendGrams , inputs : [ { name : dest , type : uint256 }, { name : amount , type : uint64 } ], outputs : [ ] } ], events : [ ], data : [ ] }; async function get_grams_from_giver(client, account) { const { contracts, queries } = client; const result = await contracts.run({ address: giverAddress, functionName: 'sendGrams', abi: giverAbi, input: { dest: `0x${account}`, amount: 10000000000 }, keyPair: null, }); const wait = await queries.accounts.waitFor( { id: { eq: account }, storage: { balance: { Grams: { gt: 0 } } } }, 'id storage {balance {Grams}}' ); }; Now you need to calculate future address by generating deploy message of the contract to know where to transfer funds for deploy. const futureHelloAddress = (await client.contracts.createDeployMessage({ package: HelloContract.package, constructorParams: {}, keyPair: helloKeys, })).address; console.log(`Future address of the contract will be: ${futureHelloAddress}`); Transfer some grams to this address: await get_grams_from_giver(client, futureHelloAddress); console.log(`Grams were transfered from giver to ${futureHelloAddress}`); Now you are ready to initialize the account with contract code by deploying it. Run const helloAddress = (await client.contracts.deploy({ package: HelloContract.package, constructorParams: {}, keyPair: helloKeys, })).address; console.log(`Hello contract was deployed at address: ${helloAddress}`); The package parameter is a structure with two fields: abi and imageBase64 , where: abi is a contract ABI; imageBase64 is the TVC code encoded with base64. The contructorParams includes parameters passed to the constructor. It can be empty and expressed as {} , if the constructor has no parameters. The keyPair is a mandatory parameter that specifies the following: public key is placed into contract initial state as a rule for deploying ABI-based contracts; secret key is used to sign a constructor invocation. The deployment method executes the following sequence: Prepares a deploy request. Sends a constructor message to a node Waits until the deployment is complete. Generates the constructor invocation request. Sends the invocation to the blockchain node. Waits until the invocation phase is complete. The returned result contains an account address assigned to the newly deployed contract.","title":"Deploying contracts"},{"location":"2. SDK/Client Libraries/Library Modules/1. Contracts/#running-contracts","text":"","title":"Running contracts"},{"location":"2. SDK/Client Libraries/Library Modules/1. Contracts/#running-functions","text":"Running a contract implies the following steps: Generating an input message to contract with a function name and parameter values. Posting this message to the node. Waiting until the node runs the contract at the TVM, recording the result into blockchain and synchronizing the changes with TON. Reading an output message with function result from the blockchain and decoding it. In the SDK all these steps are incorporated within the run library method. To run a contract, we need its address, an ABI, a function name with parameters and a key pair if message signing is required. const resut = await client.contracts.run({ address: helloAddress, abi: HelloContract.package.abi, functionName: 'sayHello', input: {}, keyPair: helloKeys, }); The result contains the output field with a decoded output message returned by the source contract function. If an optional keyPair parameter is specified, the input message is signed and accompanied with a public key. So, the contract can perform authorization using a verifiable public key passed to it.","title":"Running functions"},{"location":"2. SDK/Client Libraries/Library Modules/1. Contracts/#running-locally","text":"Cases are when all a contract function does is calculate some data based on the current contract state and return the calculation result. In these cases we do not need the standard sequence to run a contract. Instead, the following steps are taken: Generate an input message to contract with a function name and parameter values. Read the current contract state into an application. The contract state is taken from ArangoDB. Run the contract code on a lightweight TVM included into the client library by passing a contract state and an input message. Decode the contract output message. This running method is less time-consuming and involves no fees related to a regular contract execution. Note : local contract invocation does not impact the blockchain: all transactions, message and state change produces are just discarded. To execute a contract inside an application just use the runLocal method instead of run . The parameters are the same, only the method name differs. const localResponse = await client.contracts.runLocal({ address: helloAddress, abi: HelloContract.package.abi, functionName: 'sayHello', input: {}, keyPair: helloKeys, });","title":"Running  locally"},{"location":"2. SDK/Client Libraries/Library Modules/1. Contracts/#decoding-messages","text":"Some contract functions can generate output messages targeted at some external services. Mainly, these are integration services designed as a glue between blockchain contracts and regular REST (or similar) services. Typically, these services use the following scenario: The service subscribes to messages changes in a blockchain. Usually a subscription is filtered by messages related to a specific account. When a new message comes to a blockchain, an integration service is triggered. It reads and decodes this message. Then, the integration service invokes an offchain service using parameters according to the decoded data. For these services the Client library provides the decodeOutputMessage method. It decodes output messages recorded into a blockchain. In addition to decoding output messages the Client library provides the decodeInputMessage method that decodes input messages. Note : Decoding requires an ABI and is only applicable to ABI compliant messages. Advanced Features","title":"Decoding messages"},{"location":"2. SDK/Client Libraries/Library Modules/1. Contracts/#advanced-features","text":"","title":"Advanced Features"},{"location":"2. SDK/Client Libraries/Library Modules/1. Contracts/#signing-messages-externally","text":"Although the library provides friendly and simple functions to deploy and run contracts, there are cases when more precision and control is required to deploy and run an application contract. For example, an application can use a crypto provider inaccessible from the client library (e.g. a JavaCard crypto provider). To solve this, the library offers several functions: createUnsignedDeployRequest and createUnsignedRunRequest \u2013 these functions take the same parameters as the deploy or run functions except that instead of keyPair only the public key is passed. This function returns an encoded message body and a byte buffer required to produce a signature. createSignedDeployMessage and createSignedRunMessage \u2013 this functions take an unsigned message body, sign bytes and the public key. The output is a message compatible with a blockchain node. createDeployMessage and createRunMessage \u2013 these functions generate the same sequence. The example below shows how to create an unsigned deploy message, sign it and then combine the unsigned message with the signature and finally to deploy the signed message. async function testExternalSigning(client) { const { contracts, crypto } = client; // Generate Key Pair const masterKeys = await crypto.ed25519Keypair(); // Prepare deploy params and use only public key const deployParams = { package: events_package, constructorParams: {}, keyPair: { public: masterKeys.public, secret: '' }, }; // Create unsigned deploy message const unsignedMessage = await contracts.createUnsignedDeployMessage(deployParams); const bytesToSignBase64 = unsignedMessage.signParams.bytesToSignBase64; // Create signature for bytes buffer // This can be done in isolated secret place like a HSM const signBytesBase64 = await crypto.naclSignDetached( { base64: bytesToSignBase64 }, `${masterKeys.secret}${masterKeys.public}`, TONOutputEncoding.Base64 ); // Create signed message with provided sign const signed = await contracts.createSignedDeployMessage({ address: unsignedMessage.address, createSignedParams: { publicKeyHex: masterKeys.public, signBytesBase64: signBytesBase64, unsignedBytesBase64: unsignedMessage.signParams.unsignedBytesBase64, } }); // Deploy signed message const message = await contracts.createDeployMessage(deployParams); expect(signed.message.messageBodyBase64).toEqual(message.message.messageBodyBase64); }","title":"Signing messages externally"},{"location":"2. SDK/Client Libraries/Library Modules/2. Queries/","text":"Use the SDK to make queries to blockchain objects. A live blockchain snapshot is accessible through an ArangoDB instance in the local node. To query it, GraphQL protocol with subscription options is implemented (get the schema at http://127.0.0.1/graphql ). All data in the database are divided into following collections: accounts : blockchain account data; transactions : transactions related to accounts; messages: input and output messages related to transactions; blocks: blockchain blocks. The structure of each collection item matches that on the TON blochchain. So, for additional details on specific fields refer to official TON documentation. The queries module of the Client library defines four objects to access each collection: accounts , transactions , messages and blocks . Each object has a set of query methods: query : filters collection items according to the requested condition. The available filtration functionality covers a wide range of tasks. If none of the collection items matches the request, an empty set is returned. waitFor : same as above, but this method never returns until the requested item appears (i.e. it actually waits). subscribe : starts monitoring the relevant blockchain for items matching the requests. The subscription monitors all insert and update operations. Making queries To perform a query over the relevant blockchain, choose a collection and then specify a filter, result projection, sorting order and the maximum number of items in the results list. const transactions = await client.queries.transactions.query({ now: { eq: 1567601735 } }, 'id now status'); The example above demonstrates a query to the transactions collection with the following parameters: filter : a JSON object matching the internal collection structure. It supports additional conditions for particular fields. In the example above, the now field of a transaction must be equal to 1567601735. result : is a result projection that deter structural subset used for returning items. In the example above the request is limited to three fields: id , now and status . Note that results have to follow GraphQL rules. Given that the now field is unique in the example, the transactions array is either empty or contains one item. The waitFor method can be used to obtain items that are not yet written to the blockchain but are expected to appear. const transactions = await client.queries.transactions.waitFor({ now: { eq: 1567601735 } }, 'id now status'); The signature of the waitFor is exactly the same as for the query . The only difference is behavior: if there is no transaction with the specified now in the requested blockchain, this method waits indefinitely until the transaction appears in the blockchain. Subscriptions Some applications monitor blockchain for a specific data set or for potential updates. The subscribe method (included in collection object) handles these scenarios: const subscription = client.queries.blocks.subscribe({}, 'id', (e, doc) = { console.log('On block have created: ', doc); }); setTimeout(() = { subscription.unsubscribe(); resolve(); }, 10*60*1000); In this example, we start a subscription and react whenever a block is inserted or updated in the relevant blockchain. The filter and result parameters are the same as in the query method. The filter parameter narrows the action down to a subset of monitored items. In this case, the filter is empty: all items are included into monitoring. The last parameter is an event handler. This event is triggered every time the monitored block is inserted or updated in the relevant blockchain. The return value of the subscribe method is a subscription object with one available method: unsubscribe . The subscription remains active until it is called. In the example above the subscription is cancelled within 10 min. Filtration and sorting Filters applied to querying functions are data structures matching collection items with several extra features: The value for scalar fields (e.g. strings, numbers etc.) is a structure with the scalar filter. The value for array fields is a structure with an array filter. The value for nested structures is a filter for nested structure. Scalar filters Scalar filter is a structure with one or more predefined fields. Each field defines a specific scalar operation and a reference value: eq : item value must be equal to the specified value; ne : item value must not be equal to the specified value; gt : item value must be greater than the specified value; lt : item value must be less than specified value; ge : item value must be greater than or equal to the specified value; le : item value must be less than or equal to the specified value; in : item value must be contained in the specified array of values; notIn : item value must not be contained within the specified array of values. Filter example: { id: { eq: 'e19948d53c4fc8d405fbb8bde4af83039f37ce6bc9d0fc07bbd47a1cf59a8465'}, status: { in: [ Preliminary , Proposed , Finalized ] } } Note that when a scalar filter for a field contains multiple operators, the AND logical operator is used to combine all the conditions: { now: { gt: 1563449, lt: 2063449 } } The logic from the above snippet can be expressed in the following way: (transaction.now 1563449) (transaction.now 2063449) Array filters Array filters are used for array (list) fields. Each has to contain at least one of the predefined operators: any : used when at least one array item matches the nested filter; all : used when all items matches the nested filter. The any or all must contain a nested filter for an array item. Array operators are mutually exclusive and can not be combined. For empty arrays, the array filter is assumed to be false. Structure filters If an item is a structure, then a filter has to contain fields named as fields of this item. Each nested filter field contains a condition for the appropriate field of an item. The AND operator is used to combine conditions for several fields. Joins The NoSQL database contains additional fields that work as cross-references for related collections. For example, the transactions collection has the in_message field that stores the relevant message item. The message item exists in messages collection and has the id value equal to the in_msg value in transactions . Joined items are represented as nested structures in a filter and in the result projection. Sorting and limiting By default, retrieval order for several items is not defined. To specify it, use the orderBy parameter of query method. The sort order is represented by an array or sort descriptors. These structures contain two fields: path and direction : path specifies a path from a root item of the collection to the field that determines the order of return items. The path includes field names separated by dot. direction specifies the sorting order: ASC or DESC (ascending and descending). You can specify more than one field to define an order. If two items have equal values for the first sort descriptor, then second descriptor is used for comparison, etc. If values of sorting fields are the same for several items, then the order of these items is not defined. The limit parameter determines the maximum number of items returned. This parameter has a default value of 50 and can not exceed it. If specified limit exceeds 50, 50 is used. Special fields Each items in each collection has a unique key stored in the id field. This ID is the same as the item blockchain identifier.","title":"2. Queries"},{"location":"2. SDK/Client Libraries/Library Modules/2. Queries/#making-queries","text":"To perform a query over the relevant blockchain, choose a collection and then specify a filter, result projection, sorting order and the maximum number of items in the results list. const transactions = await client.queries.transactions.query({ now: { eq: 1567601735 } }, 'id now status'); The example above demonstrates a query to the transactions collection with the following parameters: filter : a JSON object matching the internal collection structure. It supports additional conditions for particular fields. In the example above, the now field of a transaction must be equal to 1567601735. result : is a result projection that deter structural subset used for returning items. In the example above the request is limited to three fields: id , now and status . Note that results have to follow GraphQL rules. Given that the now field is unique in the example, the transactions array is either empty or contains one item. The waitFor method can be used to obtain items that are not yet written to the blockchain but are expected to appear. const transactions = await client.queries.transactions.waitFor({ now: { eq: 1567601735 } }, 'id now status'); The signature of the waitFor is exactly the same as for the query . The only difference is behavior: if there is no transaction with the specified now in the requested blockchain, this method waits indefinitely until the transaction appears in the blockchain.","title":"Making queries"},{"location":"2. SDK/Client Libraries/Library Modules/2. Queries/#subscriptions","text":"Some applications monitor blockchain for a specific data set or for potential updates. The subscribe method (included in collection object) handles these scenarios: const subscription = client.queries.blocks.subscribe({}, 'id', (e, doc) = { console.log('On block have created: ', doc); }); setTimeout(() = { subscription.unsubscribe(); resolve(); }, 10*60*1000); In this example, we start a subscription and react whenever a block is inserted or updated in the relevant blockchain. The filter and result parameters are the same as in the query method. The filter parameter narrows the action down to a subset of monitored items. In this case, the filter is empty: all items are included into monitoring. The last parameter is an event handler. This event is triggered every time the monitored block is inserted or updated in the relevant blockchain. The return value of the subscribe method is a subscription object with one available method: unsubscribe . The subscription remains active until it is called. In the example above the subscription is cancelled within 10 min.","title":"Subscriptions"},{"location":"2. SDK/Client Libraries/Library Modules/2. Queries/#filtration-and-sorting","text":"Filters applied to querying functions are data structures matching collection items with several extra features: The value for scalar fields (e.g. strings, numbers etc.) is a structure with the scalar filter. The value for array fields is a structure with an array filter. The value for nested structures is a filter for nested structure.","title":"Filtration and sorting"},{"location":"2. SDK/Client Libraries/Library Modules/2. Queries/#scalar-filters","text":"Scalar filter is a structure with one or more predefined fields. Each field defines a specific scalar operation and a reference value: eq : item value must be equal to the specified value; ne : item value must not be equal to the specified value; gt : item value must be greater than the specified value; lt : item value must be less than specified value; ge : item value must be greater than or equal to the specified value; le : item value must be less than or equal to the specified value; in : item value must be contained in the specified array of values; notIn : item value must not be contained within the specified array of values. Filter example: { id: { eq: 'e19948d53c4fc8d405fbb8bde4af83039f37ce6bc9d0fc07bbd47a1cf59a8465'}, status: { in: [ Preliminary , Proposed , Finalized ] } } Note that when a scalar filter for a field contains multiple operators, the AND logical operator is used to combine all the conditions: { now: { gt: 1563449, lt: 2063449 } } The logic from the above snippet can be expressed in the following way: (transaction.now 1563449) (transaction.now 2063449)","title":"Scalar filters"},{"location":"2. SDK/Client Libraries/Library Modules/2. Queries/#array-filters","text":"Array filters are used for array (list) fields. Each has to contain at least one of the predefined operators: any : used when at least one array item matches the nested filter; all : used when all items matches the nested filter. The any or all must contain a nested filter for an array item. Array operators are mutually exclusive and can not be combined. For empty arrays, the array filter is assumed to be false.","title":"Array filters"},{"location":"2. SDK/Client Libraries/Library Modules/2. Queries/#structure-filters","text":"If an item is a structure, then a filter has to contain fields named as fields of this item. Each nested filter field contains a condition for the appropriate field of an item. The AND operator is used to combine conditions for several fields.","title":"Structure filters"},{"location":"2. SDK/Client Libraries/Library Modules/2. Queries/#joins","text":"The NoSQL database contains additional fields that work as cross-references for related collections. For example, the transactions collection has the in_message field that stores the relevant message item. The message item exists in messages collection and has the id value equal to the in_msg value in transactions . Joined items are represented as nested structures in a filter and in the result projection.","title":"Joins"},{"location":"2. SDK/Client Libraries/Library Modules/2. Queries/#sorting-and-limiting","text":"By default, retrieval order for several items is not defined. To specify it, use the orderBy parameter of query method. The sort order is represented by an array or sort descriptors. These structures contain two fields: path and direction : path specifies a path from a root item of the collection to the field that determines the order of return items. The path includes field names separated by dot. direction specifies the sorting order: ASC or DESC (ascending and descending). You can specify more than one field to define an order. If two items have equal values for the first sort descriptor, then second descriptor is used for comparison, etc. If values of sorting fields are the same for several items, then the order of these items is not defined. The limit parameter determines the maximum number of items returned. This parameter has a default value of 50 and can not exceed it. If specified limit exceeds 50, 50 is used.","title":"Sorting and limiting"},{"location":"2. SDK/Client Libraries/Library Modules/2. Queries/#special-fields","text":"Each items in each collection has a unique key stored in the id field. This ID is the same as the item blockchain identifier.","title":"Special fields"},{"location":"2. SDK/Client Libraries/Library Modules/3. Crypto/","text":"TON Client Library is shipped with a crypto module that contains the following set of crypto functions for TON blockchain. math and random: generate_random_bytes, modular_power, factorize; sha256, sha512; generate_random_ed25519_keys; scrypt; menmonic: mnemonic_get_words, mnemonic_generate_random, mnemonic_from_entropy, mnemonic_is_valid, mnemonic_seed_from_phrase_and_salt, mnemonic_entropy_from_phrase; HD Keys: hdkey_xprv_from_mnemonic, hdkey_secret_from_xprv, hdkey_public_from_xprv, hdkey_derive_from_xprv, hdkey_derive_from_xprv_path; NaCl: nacl_sign_keys, nacl_sign_keys_from_secret, nacl_box_keys, nacl_box_keys_from_secret_key, nacl_secret_box, nacl_secret_box_open, nacl_box, nacl_box_open, nacl_sign, nacl_sign_open, nacl_sign_detached; Key store: keystore_add, keystore_remove, clear. Key Store The crypto module holds a set of key pairs accessible through a handle. A key pair can be added to a key store or removed from it. Once added to a keystore, a key pair gets a handle assigned to it. This handle can be used in relevant crypto functions instead of the key pair itself. Reference Links Follow the link to our github repository to get the list of our crypto-functions: https://github.com/tonlabs/ton-client-js/blob/75270514d6e1051fe7159b7bcc79f1110ebe6d1b/types.js#L55 These functions are standard and familiar to the professional audience. For a brief guide, follow the link: https://github.com/dchest/tweetnacl-js/blob/master/README.md#documentation (search for functions starting with nacl ).","title":"3. Crypto"},{"location":"2. SDK/Client Libraries/Library Modules/3. Crypto/#key-store","text":"The crypto module holds a set of key pairs accessible through a handle. A key pair can be added to a key store or removed from it. Once added to a keystore, a key pair gets a handle assigned to it. This handle can be used in relevant crypto functions instead of the key pair itself.","title":"Key Store"},{"location":"2. SDK/Client Libraries/Library Modules/3. Crypto/#reference-links","text":"Follow the link to our github repository to get the list of our crypto-functions: https://github.com/tonlabs/ton-client-js/blob/75270514d6e1051fe7159b7bcc79f1110ebe6d1b/types.js#L55 These functions are standard and familiar to the professional audience. For a brief guide, follow the link: https://github.com/dchest/tweetnacl-js/blob/master/README.md#documentation (search for functions starting with nacl ).","title":"Reference Links"},{"location":"2. SDK/Client Libraries/Using Libraries/2. Node.js/","text":"Follow guidelines in this section to create your own environment based on Node.js with the Node SE tools and to develop your first test contract. First and foremost, create a local folder for all your test projects. Note that in this documentation the sample folder is called ton-dev . If your folder has a different name, make sure to edit the code accordingly. Creating a contract Create \"hello\" folder and place the \"hello.sol\" contract source code into it: pragma solidity =0.5.0 0.6.0; contract HelloTON { uint32 deployTime; constructor() public { deployTime = uint32(now); } function sayHello() public view returns (uint32) { return deployTime; } } \u200b Call cd hello to navigate to the new folder. Run TON labs Sol2TVM compiler: tondev sol hello -l js -L deploy -l js option is used to generate JavaScript client helper code for the compiled contract. -L deploy is used to include an imageBase64 field into the generated JavaScript contract client code. Creating an app Before being able to play with a smart contract on the blockchain, we need a blockchain infrastructure for contract testing and debugging. Make sure that you started a local node instance according to the guidelines provided in the Installation section. tondev start Let's start with Node.js to show how to build a test application, deploy and run its smart contract. Note: To create an application according to this procedure, you have to install Node.js. It is recommended to have the latest version. Let's initialize a Node.js application: ~/ton-dev/hello$ touch index.js ~/ton-dev/hello$ npm init Add a section to package.json: dependencies : { ton-client-node-js : ^0.12.1 } Then execute (in the project folder): ~/ton-dev/hello$ npm install \\2. Connect to Node SE or to TON Labs testnet. In JS Client Libraries the TONClient class is used to connect to TON Blockchain node, that can work with SDK. If you use the local node (NodeSE), specify ' http://0.0.0.0 ' in the following code: const client = new TONClient(); client.config.setData({ servers: [' http://0.0.0.0 '] }); Important : for Windows use http://127.0.0.1/ or http://localhost . If you use TON Labs testnet, specify: servers: ['Node URL']. For testing we use ' https://testnet.ton.dev ' : const client = new TONClient(); client.config.setData({ servers: [' https://https://testnet.ton.dev '] }); In JS Client you can simultaneously use several nodes. Create a separate TONClient object for each connection. Open the \"index.js\" file in your preferred editor and enter the code below. const { TONClient } = require('ton-client-node-js'); async function main(client) { } (async () = { try { const client = new TONClient(); client.config.setData({ servers: ['NodeSE/Testnet URL'] }); await client.setup(); await main(client); console.log('Hello TON Done'); process.exit(0); } catch (error) { console.error(error); } })(); Run the client app as follows: ~/ton-dev/hello$ node index.js Hello TON Done ~/ton-dev/hello$ Deployment Before a contract is deployed, it has to be defined in your node.js application. The necessary elements are: a compatible TVM code and an ABI structure. Both elements were obtained at the compilation stage before in the helloPackage.js file. Tip : For more details on the ABI, see the specification . For deployment, you also have to take the following steps: Generate the key pair. Each time a contract is deployed, you can generate keys with a built-in ton.crypto.ed25519Keypair crypto module. Or use pre-generated keys to get predictable results. It is the option used for this example: { public: '55d7bab463a6a3ef5e03bb5f975836ddfb589b9ccb00329be7da8ea981c5268a', secret: 'de93a97c7103c2d44e47972265cfdfe266fd28c8cadc4875804ee9f57cf786d6', } Switch to your test app source code to declare a smart contract package and the relevant key pair: ... // Define contract package const HelloContract = require('./helloContract'); // Define keys for our contract const helloKeys = { public: '55d7bab463a6a3ef5e03bb5f975836ddfb589b9ccb00329be7da8ea981c5268a', secret: 'de93a97c7103c2d44e47972265cfdfe266fd28c8cadc4875804ee9f57cf786d6', }; async function main(client) { } ... The contract is almost ready for deployment, but in TON blockchain you must deposit GRAMs to the address of the deployed contract before the actual deploy . Otherwise deploy will fail. You can send Grams from another contract or use our giver. To learn how to use giver, check the relevant section in the document covering the Contracts module. There is a detailed usage example. ... async function main(client) { const helloAddress = (await client.contracts.deploy({ package: HelloContract.package, constructorParams: {}, keyPair: helloKeys, })).address; console.log(`Hello contract was deployed at address: ${helloAddress}`); } ... Now run to check how it works. ~/ton-dev/hello$ node index.js Hello contract was deployed at address: 516c7a2bc72c5728526eb73064da07a2876d964c3da5ed2488e1aba3da20be3f ~/ton-dev/hello$ Running a contract Running your contract on blockchain is also quite simple ... async function main(client) { const helloAddress = (await client.contracts.deploy({ package: HelloContract.package, constructorParams: {}, keyPair: helloKeys, })).address; console.log(`Hello contract was deployed at address: ${helloAddress}`); const response = await client.contracts.run({ address: helloAddress, abi: HelloContract.package.abi, functionName: 'sayHello', input: {}, keyPair: helloKeys, }); console.log('Hello contract was responded to sayHello:', response); } ... Now run the app: ~/ton-dev/hello$ node index.js Hello contract was deployed at address: 516c7a2bc72c5728526eb73064da07a2876d964c3da5ed2488e1aba3da20be3f Hello contract was responded to sayHello: { output: { value0: '0x5d6fba2e' } } Hello TON Done ~/ton-dev/hello$ Alternatively, you can run a contract in the TVM instance included into a client library without interaction with TVM node: ... async function main(client) { const helloAddress = (await client.contracts.deploy({ package: HelloContract.package, constructorParams: {}, keyPair: helloKeys, })).address; console.log(`Hello contract was deployed at address: ${helloAddress}`); const response = await client.contracts.run({ address: helloAddress, abi: HelloContract.package.abi, functionName: 'sayHello', input: {}, keyPair: helloKeys, }); console.log('Hello contract was responded to sayHello:', response); const localResponse = await client.contracts.runLocal({ address: helloAddress, abi: HelloContract.package.abi, functionName: 'sayHello', input: {}, keyPair: helloKeys, }); console.log('Hello contract was ran on a client TVM and also responded to sayHello:', localResponse); } ... Run: ~/ton-dev/hello$ node index.js Hello contract was deployed at address: 516c7a2bc72c5728526eb73064da07a2876d964c3da5ed2488e1aba3da20be3f Hello contract was responded to sayHello: { output: { value0: '0x5d6fba2e' } } Hello contract was ran on a client TVM and also responded to sayHello: { output: { value0: '0x5d6fba2e' } } Hello TON Done ~/ton-dev/hello$ Find more information about deploying and running in the Contracts section. Querying blockchain Each node server is equipped with a database that tracks the relevant blockchain. This database is accessible through a GraphQL based protocol for querying blockchain. The Client library contains the Query Module designed to perform GraphQL queries over a blockchain. The simplest way to query a blockchain is using the following query method: async function queries(client) { const transactions = await client.queries.transactions.query({}, 'id now status'); console.log('All Transactions: ', transactions); } Then all transactions in the relevant blockchain are displayed (the first 50, to be precise). 50 is the default number used when no limit is specified or when it exceeds 50. For each transaction, we have three result fields: id , now and status . We have several options to filter the results: const transactions = await client.queries.transactions.query({ now: { eq: 1567601735 } }, 'id now status'); console.log('Filtered Transactions: ', transactions); The example gets all transactions with now equals to 1567601735. Find more information about a filtering in the Queries section.","title":"2. Node.js"},{"location":"2. SDK/Client Libraries/Using Libraries/2. Node.js/#creating-a-contract","text":"Create \"hello\" folder and place the \"hello.sol\" contract source code into it: pragma solidity =0.5.0 0.6.0; contract HelloTON { uint32 deployTime; constructor() public { deployTime = uint32(now); } function sayHello() public view returns (uint32) { return deployTime; } } \u200b Call cd hello to navigate to the new folder. Run TON labs Sol2TVM compiler: tondev sol hello -l js -L deploy -l js option is used to generate JavaScript client helper code for the compiled contract. -L deploy is used to include an imageBase64 field into the generated JavaScript contract client code.","title":"Creating a contract"},{"location":"2. SDK/Client Libraries/Using Libraries/2. Node.js/#creating-an-app","text":"Before being able to play with a smart contract on the blockchain, we need a blockchain infrastructure for contract testing and debugging. Make sure that you started a local node instance according to the guidelines provided in the Installation section. tondev start Let's start with Node.js to show how to build a test application, deploy and run its smart contract. Note: To create an application according to this procedure, you have to install Node.js. It is recommended to have the latest version. Let's initialize a Node.js application: ~/ton-dev/hello$ touch index.js ~/ton-dev/hello$ npm init Add a section to package.json: dependencies : { ton-client-node-js : ^0.12.1 } Then execute (in the project folder): ~/ton-dev/hello$ npm install \\2. Connect to Node SE or to TON Labs testnet. In JS Client Libraries the TONClient class is used to connect to TON Blockchain node, that can work with SDK. If you use the local node (NodeSE), specify ' http://0.0.0.0 ' in the following code: const client = new TONClient(); client.config.setData({ servers: [' http://0.0.0.0 '] }); Important : for Windows use http://127.0.0.1/ or http://localhost . If you use TON Labs testnet, specify: servers: ['Node URL']. For testing we use ' https://testnet.ton.dev ' : const client = new TONClient(); client.config.setData({ servers: [' https://https://testnet.ton.dev '] }); In JS Client you can simultaneously use several nodes. Create a separate TONClient object for each connection. Open the \"index.js\" file in your preferred editor and enter the code below. const { TONClient } = require('ton-client-node-js'); async function main(client) { } (async () = { try { const client = new TONClient(); client.config.setData({ servers: ['NodeSE/Testnet URL'] }); await client.setup(); await main(client); console.log('Hello TON Done'); process.exit(0); } catch (error) { console.error(error); } })(); Run the client app as follows: ~/ton-dev/hello$ node index.js Hello TON Done ~/ton-dev/hello$","title":"Creating an app"},{"location":"2. SDK/Client Libraries/Using Libraries/2. Node.js/#deployment","text":"Before a contract is deployed, it has to be defined in your node.js application. The necessary elements are: a compatible TVM code and an ABI structure. Both elements were obtained at the compilation stage before in the helloPackage.js file. Tip : For more details on the ABI, see the specification . For deployment, you also have to take the following steps: Generate the key pair. Each time a contract is deployed, you can generate keys with a built-in ton.crypto.ed25519Keypair crypto module. Or use pre-generated keys to get predictable results. It is the option used for this example: { public: '55d7bab463a6a3ef5e03bb5f975836ddfb589b9ccb00329be7da8ea981c5268a', secret: 'de93a97c7103c2d44e47972265cfdfe266fd28c8cadc4875804ee9f57cf786d6', } Switch to your test app source code to declare a smart contract package and the relevant key pair: ... // Define contract package const HelloContract = require('./helloContract'); // Define keys for our contract const helloKeys = { public: '55d7bab463a6a3ef5e03bb5f975836ddfb589b9ccb00329be7da8ea981c5268a', secret: 'de93a97c7103c2d44e47972265cfdfe266fd28c8cadc4875804ee9f57cf786d6', }; async function main(client) { } ... The contract is almost ready for deployment, but in TON blockchain you must deposit GRAMs to the address of the deployed contract before the actual deploy . Otherwise deploy will fail. You can send Grams from another contract or use our giver. To learn how to use giver, check the relevant section in the document covering the Contracts module. There is a detailed usage example. ... async function main(client) { const helloAddress = (await client.contracts.deploy({ package: HelloContract.package, constructorParams: {}, keyPair: helloKeys, })).address; console.log(`Hello contract was deployed at address: ${helloAddress}`); } ... Now run to check how it works. ~/ton-dev/hello$ node index.js Hello contract was deployed at address: 516c7a2bc72c5728526eb73064da07a2876d964c3da5ed2488e1aba3da20be3f ~/ton-dev/hello$","title":"Deployment"},{"location":"2. SDK/Client Libraries/Using Libraries/2. Node.js/#running-a-contract","text":"Running your contract on blockchain is also quite simple ... async function main(client) { const helloAddress = (await client.contracts.deploy({ package: HelloContract.package, constructorParams: {}, keyPair: helloKeys, })).address; console.log(`Hello contract was deployed at address: ${helloAddress}`); const response = await client.contracts.run({ address: helloAddress, abi: HelloContract.package.abi, functionName: 'sayHello', input: {}, keyPair: helloKeys, }); console.log('Hello contract was responded to sayHello:', response); } ... Now run the app: ~/ton-dev/hello$ node index.js Hello contract was deployed at address: 516c7a2bc72c5728526eb73064da07a2876d964c3da5ed2488e1aba3da20be3f Hello contract was responded to sayHello: { output: { value0: '0x5d6fba2e' } } Hello TON Done ~/ton-dev/hello$ Alternatively, you can run a contract in the TVM instance included into a client library without interaction with TVM node: ... async function main(client) { const helloAddress = (await client.contracts.deploy({ package: HelloContract.package, constructorParams: {}, keyPair: helloKeys, })).address; console.log(`Hello contract was deployed at address: ${helloAddress}`); const response = await client.contracts.run({ address: helloAddress, abi: HelloContract.package.abi, functionName: 'sayHello', input: {}, keyPair: helloKeys, }); console.log('Hello contract was responded to sayHello:', response); const localResponse = await client.contracts.runLocal({ address: helloAddress, abi: HelloContract.package.abi, functionName: 'sayHello', input: {}, keyPair: helloKeys, }); console.log('Hello contract was ran on a client TVM and also responded to sayHello:', localResponse); } ... Run: ~/ton-dev/hello$ node index.js Hello contract was deployed at address: 516c7a2bc72c5728526eb73064da07a2876d964c3da5ed2488e1aba3da20be3f Hello contract was responded to sayHello: { output: { value0: '0x5d6fba2e' } } Hello contract was ran on a client TVM and also responded to sayHello: { output: { value0: '0x5d6fba2e' } } Hello TON Done ~/ton-dev/hello$ Find more information about deploying and running in the Contracts section.","title":"Running a contract"},{"location":"2. SDK/Client Libraries/Using Libraries/2. Node.js/#querying-blockchain","text":"Each node server is equipped with a database that tracks the relevant blockchain. This database is accessible through a GraphQL based protocol for querying blockchain. The Client library contains the Query Module designed to perform GraphQL queries over a blockchain. The simplest way to query a blockchain is using the following query method: async function queries(client) { const transactions = await client.queries.transactions.query({}, 'id now status'); console.log('All Transactions: ', transactions); } Then all transactions in the relevant blockchain are displayed (the first 50, to be precise). 50 is the default number used when no limit is specified or when it exceeds 50. For each transaction, we have three result fields: id , now and status . We have several options to filter the results: const transactions = await client.queries.transactions.query({ now: { eq: 1567601735 } }, 'id now status'); console.log('Filtered Transactions: ', transactions); The example gets all transactions with now equals to 1567601735. Find more information about a filtering in the Queries section.","title":"Querying blockchain"},{"location":"2. SDK/Client Libraries/Using Libraries/3. Rust/","text":"Make sure to create a local folder for all your test projects. Creating a contract Create the \"hello\" folder and place the \"hello.sol\" contract source code into it: pragma solidity =0.5.0 0.6.0; contract HelloTON { uint32 deployTime; constructor() public { deployTime = uint32(now); } function sayHello() public view returns (uint32) { return deployTime; } } Call cd hello to navigate to the new folder. Run the TON Labs Solidity compiler: tondev sol hello Creating an app To get a functional playground, we need blockchain infrastructure for contract testing and debugging. We suggest using our Node SE. Make sure that you ran a Node SE instant according to the guidelines provided in the Installation section. tondev start Note: To create an application according to this procedure, you have to install the newest Rust compiler. Initialize a Rust application in the hello directory: ~/ton-dev/hello$ cargo init Created binary (application) package Open the newly created Cargo.toml file in your preferred editor and add following line to the [dependencies] section: ton-client-rs = 0.11.1 It enables using TON SDK Client package in your hello project. Connect to the local node (Node SE) or to TON Labs testnet. In Rust Client Libraries the TONClient class is used to connect to TON Blockchain nodes that can work with SDK. If you use Node SE, specify new_with_base_url(\" http://0.0.0.0 \") (local URL). Important : for Windows use http://127.0.0.1/ or http://localhost . If you use the testnet, specify its URL. For test purposes, use Ton Labs test net URL new_with_base_url(' https://testnet.ton.dev ') Go to the main.rs file in hello/src and paste the following code into it: extern crate ton_client_rs; use ton_client_rs::TonClient; fn main() { let ton = TonClient::new_with_base_url( NodeSE/testnet URL ).expect( Couldn't create TonClient ); println!( Hello TON Done ); } Run the client app from hello directory: ~/ton-dev/hello$ cargo run ... Running `target\\\\debug\\\\hello.exe` Hello TON Done ~/ton-dev/hello$ Generate keys to sign the deploy transaction using ton_client.crypto.generate_ed25519_keys() function: extern crate ton_client_rs; use ton_client_rs::TonClient; fn main() { let ton = TonClient::new_with_base_url( http://0.0.0.0 ).expect( Couldn't create TonClient ); play_with_ton(ton); println!( Hello TON Done ); } fn play_with_ton(ton_client: TonClient) { let keys = ton_client.crypto.generate_ed25519_keys().expect( Couldn't create key pair ); println!( Generated keys: {}:{} , keys.secret, keys.public); } Deployment Before a contract can be deployed, the application needs retrieve: a compatible TVM code and an ABI structure. Both elements were obtained at the compilation stage and stored in the hello.tvc and hello.abi.json . Tip : For more details on the ABI, see the specification . Below is the final contract deployment code: ... fn play_with_ton(ton_client: TonClient) { let keys = ton_client.crypto.generate_ed25519_keys().expect( Couldn't create key pair ); println!( Generated keys:\\n{}\\n{} , keys.secret, keys.public); let code = std::fs::read( hello.tvc ).expect( Couldn't read code file ); let abi = std::fs::read_to_string( hello.abi.json ).expect( Couldn't read ABI file ); let address = ton_client.contracts.deploy( abi, code, {} .into(), keys) .expect( Couldn't deploy contract ); println!( Hello contract was deployed at address: {} , address); } ... Run the contract to see how it works. ~/ton-dev/hello$ cargo run ... Running `target\\\\debug\\\\hello.exe` Generated keys: 4236d45d544eccd16b16dea85f8aa201a7edfee06bb7f3e307c0ec02f9cb35ef 02154a29510c8bf29c4b4998e6510f60f224ab566eefaeaa9df22d7a90297b7e Hello contract was deployed at address: b2a0d72b81d2cfae8bd3e7dc60c20a9f478570b8bea749318ff84fa0bd46d6bd Hello TON Done ~/ton-dev/hello$ Running a contract Run your contract; it is also quite simple: ... fn play_with_ton(ton_client: TonClient) { let keys = ton_client.crypto.generate_ed25519_keys().expect( Couldn't create key pair ); println!( Generated keys:\\\\n{}\\\\n{} , keys.secret, keys.public); let code = std::fs::read( hello.tvc ).expect( Couldn't read code file ); let abi = std::fs::read_to_string( hello.abi.json ).expect( Couldn't read ABI file ); let address = ton_client.contracts.deploy( abi, code, {} .into(), keys) .expect( Couldn't deploy contract ); println!( Hello contract was deployed at address: {} , address); let response = ton_client.contracts.run( address, abi, sayHello , {} .into(), Some( keys)) .expect( Couldn't run contract ); println!( Hello contract was responded to sayHello: {} , response); } ... Then run the app: ~/ton-dev/hello$ cargo run ... Running `target\\\\debug\\\\hello.exe` Generated keys: a7571d6041d45c261759caa04f73034396bf1a3aa35f092d5eb83a407f8284f8 1fcf08942290cf190287659f078199b0901e9403d852142f241c630e9b1ca6b3 Hello contract was deployed at address: d8634d6164b02c3a6c1447c505147ca1dde6149ba02b61f9eb21915d62467fde Hello contract was responded to sayHello: { value0 : 0x5d78a4c7 } Hello TON Done ~/ton-dev/hello$ You can find more information about deploying and running in the Working with contracts section. Querying blockchain Each node server is equipped with a database that tracks the relevant blockchain. This database is accessible through a GraphQL based protocol for querying blockchain. The Client library contains the Query Module designed to perform GraphQL queries over a blockchain. The simplest way to query a blockchain is using the following query method: const TRANSACTION_FIELDS: str = r# id now status #; let query_result = ton.queries.transactions.query( json!({}).to_string(), TRANSACTION_FIELDS).unwrap(); println(query_result); Then all transactions in the relevant blockchain are displayed (the first 50, to be precise). 50 is the default number used when no limit is specified or when it exceeds 50. For each transaction, we have three result fields: id , now and status . We have several options to filter the results: const TRANSACTION_FIELDS: str = r# id now status #; let query_result = ton.queries.transactions.query( json!({ now : { eq : 1567601735 } }).to_string(), TRANSACTION_FIELDS).unwrap(); The example gets all transactions with now equals to 1567601735. Find more information about a filtering in the Queries section.","title":"3. Rust"},{"location":"2. SDK/Client Libraries/Using Libraries/3. Rust/#creating-a-contract","text":"Create the \"hello\" folder and place the \"hello.sol\" contract source code into it: pragma solidity =0.5.0 0.6.0; contract HelloTON { uint32 deployTime; constructor() public { deployTime = uint32(now); } function sayHello() public view returns (uint32) { return deployTime; } } Call cd hello to navigate to the new folder. Run the TON Labs Solidity compiler: tondev sol hello","title":"Creating a contract"},{"location":"2. SDK/Client Libraries/Using Libraries/3. Rust/#creating-an-app","text":"To get a functional playground, we need blockchain infrastructure for contract testing and debugging. We suggest using our Node SE. Make sure that you ran a Node SE instant according to the guidelines provided in the Installation section. tondev start Note: To create an application according to this procedure, you have to install the newest Rust compiler. Initialize a Rust application in the hello directory: ~/ton-dev/hello$ cargo init Created binary (application) package Open the newly created Cargo.toml file in your preferred editor and add following line to the [dependencies] section: ton-client-rs = 0.11.1 It enables using TON SDK Client package in your hello project. Connect to the local node (Node SE) or to TON Labs testnet. In Rust Client Libraries the TONClient class is used to connect to TON Blockchain nodes that can work with SDK. If you use Node SE, specify new_with_base_url(\" http://0.0.0.0 \") (local URL). Important : for Windows use http://127.0.0.1/ or http://localhost . If you use the testnet, specify its URL. For test purposes, use Ton Labs test net URL new_with_base_url(' https://testnet.ton.dev ') Go to the main.rs file in hello/src and paste the following code into it: extern crate ton_client_rs; use ton_client_rs::TonClient; fn main() { let ton = TonClient::new_with_base_url( NodeSE/testnet URL ).expect( Couldn't create TonClient ); println!( Hello TON Done ); } Run the client app from hello directory: ~/ton-dev/hello$ cargo run ... Running `target\\\\debug\\\\hello.exe` Hello TON Done ~/ton-dev/hello$ Generate keys to sign the deploy transaction using ton_client.crypto.generate_ed25519_keys() function: extern crate ton_client_rs; use ton_client_rs::TonClient; fn main() { let ton = TonClient::new_with_base_url( http://0.0.0.0 ).expect( Couldn't create TonClient ); play_with_ton(ton); println!( Hello TON Done ); } fn play_with_ton(ton_client: TonClient) { let keys = ton_client.crypto.generate_ed25519_keys().expect( Couldn't create key pair ); println!( Generated keys: {}:{} , keys.secret, keys.public); }","title":"Creating an app"},{"location":"2. SDK/Client Libraries/Using Libraries/3. Rust/#deployment","text":"Before a contract can be deployed, the application needs retrieve: a compatible TVM code and an ABI structure. Both elements were obtained at the compilation stage and stored in the hello.tvc and hello.abi.json . Tip : For more details on the ABI, see the specification . Below is the final contract deployment code: ... fn play_with_ton(ton_client: TonClient) { let keys = ton_client.crypto.generate_ed25519_keys().expect( Couldn't create key pair ); println!( Generated keys:\\n{}\\n{} , keys.secret, keys.public); let code = std::fs::read( hello.tvc ).expect( Couldn't read code file ); let abi = std::fs::read_to_string( hello.abi.json ).expect( Couldn't read ABI file ); let address = ton_client.contracts.deploy( abi, code, {} .into(), keys) .expect( Couldn't deploy contract ); println!( Hello contract was deployed at address: {} , address); } ... Run the contract to see how it works. ~/ton-dev/hello$ cargo run ... Running `target\\\\debug\\\\hello.exe` Generated keys: 4236d45d544eccd16b16dea85f8aa201a7edfee06bb7f3e307c0ec02f9cb35ef 02154a29510c8bf29c4b4998e6510f60f224ab566eefaeaa9df22d7a90297b7e Hello contract was deployed at address: b2a0d72b81d2cfae8bd3e7dc60c20a9f478570b8bea749318ff84fa0bd46d6bd Hello TON Done ~/ton-dev/hello$","title":"Deployment"},{"location":"2. SDK/Client Libraries/Using Libraries/3. Rust/#running-a-contract","text":"Run your contract; it is also quite simple: ... fn play_with_ton(ton_client: TonClient) { let keys = ton_client.crypto.generate_ed25519_keys().expect( Couldn't create key pair ); println!( Generated keys:\\\\n{}\\\\n{} , keys.secret, keys.public); let code = std::fs::read( hello.tvc ).expect( Couldn't read code file ); let abi = std::fs::read_to_string( hello.abi.json ).expect( Couldn't read ABI file ); let address = ton_client.contracts.deploy( abi, code, {} .into(), keys) .expect( Couldn't deploy contract ); println!( Hello contract was deployed at address: {} , address); let response = ton_client.contracts.run( address, abi, sayHello , {} .into(), Some( keys)) .expect( Couldn't run contract ); println!( Hello contract was responded to sayHello: {} , response); } ... Then run the app: ~/ton-dev/hello$ cargo run ... Running `target\\\\debug\\\\hello.exe` Generated keys: a7571d6041d45c261759caa04f73034396bf1a3aa35f092d5eb83a407f8284f8 1fcf08942290cf190287659f078199b0901e9403d852142f241c630e9b1ca6b3 Hello contract was deployed at address: d8634d6164b02c3a6c1447c505147ca1dde6149ba02b61f9eb21915d62467fde Hello contract was responded to sayHello: { value0 : 0x5d78a4c7 } Hello TON Done ~/ton-dev/hello$ You can find more information about deploying and running in the Working with contracts section.","title":"Running a contract"},{"location":"2. SDK/Client Libraries/Using Libraries/3. Rust/#querying-blockchain","text":"Each node server is equipped with a database that tracks the relevant blockchain. This database is accessible through a GraphQL based protocol for querying blockchain. The Client library contains the Query Module designed to perform GraphQL queries over a blockchain. The simplest way to query a blockchain is using the following query method: const TRANSACTION_FIELDS: str = r# id now status #; let query_result = ton.queries.transactions.query( json!({}).to_string(), TRANSACTION_FIELDS).unwrap(); println(query_result); Then all transactions in the relevant blockchain are displayed (the first 50, to be precise). 50 is the default number used when no limit is specified or when it exceeds 50. For each transaction, we have three result fields: id , now and status . We have several options to filter the results: const TRANSACTION_FIELDS: str = r# id now status #; let query_result = ton.queries.transactions.query( json!({ now : { eq : 1567601735 } }).to_string(), TRANSACTION_FIELDS).unwrap(); The example gets all transactions with now equals to 1567601735. Find more information about a filtering in the Queries section.","title":"Querying blockchain"},{"location":"2. SDK/Local node/Local Node/","text":"TON Labs Local Node is a pre-configured Docker image with a simplified standalone node server instance designed only for debugging and testing. Note: TON Labs Local Node is not designed to interact with the regular TON network.","title":"Local Node"},{"location":"2. SDK/Local node/Node SE Giver/","text":"If you are using the local node (Node SE) for your projects, you can use its pre-deployed Giver to transfer Grams, deploy and run other contracts. On the start Node SE giver has 1.5 billion Grams when you first create the Node container. In the course of usage, the balance dries, so to restore it, you have to recreate the container with tondev CLI recreate command To access Node SE pre-deployed giver, use this address and ABI in your projects: const nodeSeGiverAddress = 'a46af093b38fcae390e9af5104a93e22e82c29bcb35bf88160e4478417028884'; const nodeSeGiverAbi = { ABI version : 1, functions : [ { name : constructor , inputs : [ ], outputs : [ ] }, { name : sendGrams , inputs : [ { name : dest , type : uint256 }, { name : amount , type : uint64 } ], outputs : [ ] } ], events : [ ], data : [ ] }; Usage example Check it on our ton-client-js tests. Declare get_grams_from_giver function, and then invoke it to transfer grams to account that you need. async function get_grams_from_giver(account) { const { contracts, queries } = tests.client; const result = await contracts.run({ address: nodeSeGiverAddress, functionName: 'sendGrams', abi: nodeSeGiverAbi, input: { dest: `0x${account}`, amount: 500000000 }, keyPair: null, }); } For your information we demonstrate the Giver's solidity code here: pragma solidity =0.5.0 0.6.0; contract Giver { constructor() public {} function sendGrams(address payable dest, uint64 amount) public { require(address(this).balance amount, 60); dest.transfer(amount); } }","title":"Node SE Giver"},{"location":"2. SDK/Local node/Node SE Giver/#usage-example","text":"Check it on our ton-client-js tests. Declare get_grams_from_giver function, and then invoke it to transfer grams to account that you need. async function get_grams_from_giver(account) { const { contracts, queries } = tests.client; const result = await contracts.run({ address: nodeSeGiverAddress, functionName: 'sendGrams', abi: nodeSeGiverAbi, input: { dest: `0x${account}`, amount: 500000000 }, keyPair: null, }); } For your information we demonstrate the Giver's solidity code here: pragma solidity =0.5.0 0.6.0; contract Giver { constructor() public {} function sendGrams(address payable dest, uint64 amount) public { require(address(this).balance amount, 60); dest.transfer(amount); } }","title":"Usage example"},{"location":"2. SDK/TON Labs Testnet/Testnet Giver/","text":"Preparation Prerequisites Install the latest version of Docker . See installation tips in the screenshots below: For Linux users, make sure that you are able to run docker as non-root user (see https://docs.docker.com/install/linux/linux-postinstall/ ); Tip : check this page for more Docker installation options https://phoenixnap.com/kb/how-to-install-docker-on-ubuntu-18-04 . Install Node.js 10.x or newer. Make sure that Docker daemon is running on your computer. To check its status, call docker ps . Note that it is recommended to have at least 2Gb of RAM to use Node SE efficiently. Basic Installation This is the easiest version. You can only call three commands to install the solution. First, install TON Labs CLI by running: npm install -g ton-dev-cli Important : If you get errors related to permissions when trying to install packages globally, you can try to fix them using the following options: https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally . Or call: sudo chown -R $(whoami) $(npm root -g) If you fail, run the command under sudo . Then setup your machine. The step is optional, because tondev start and tondev sol perform the step on demand (see below). tondev setup Run the Local Node Call the following command to run the local node instance (Node SE): tondev start Manual Installation If you have troubles with tondev CLI utility you can install all required components yourself with the following commands: Note that Windows and Linux use different slashes ( / vs. * * ) for system paths. Make sure to change them as needed in the paths to avoid errors. docker pull tonlabs/local-node docker pull tonlabs/compilers docker create -e USER_AGREEMENT=yes --name tonlabs-local-node -i -p80:80 tonlabs/local-node mkdir user home directory /.tonlabs/compilers/projects docker create -e USER_AGREEMENT=yes --name tonlabs-compilers -it --mount type=bind,dst=/projects,src= user home directory /.tonlabs/compilers/projects tonlabs/compilers docker start tonlabs-local-node docker start tonlabs-compilers Home directory may have one of the following formats: Windows: C:\\Users\\User1 MacOS: '/Users/johnDough' Linux: /home/johnDough \u200b Install Client Libraries Tip : go to the Getting Started section, to create your own environment and a test project from scratch according to detailed guidelines. Rust Add a dependency into your cargo manifest: [dependencies] ton-client-rs = 0.11.1 Call the following command: cargo update Node.js Call the following command to install Node.js client library (the recommended version comes first): dependencies : { ton-client-node-js : ^0.12.1 } Then execute (in the project folder): ~/ton-dev/hello$ npm install Or instead of steps 1 and 2 call: npm install ton-client-node-js Web Call the following command to install client library for web browsers: npm install ton-client-web-js React Native Call the following command to install client library for React Native: npm install ton-client-react-native-js Visit TON Dev for additional product, company community info.","title":"Testnet Giver"},{"location":"2. SDK/TON Labs Testnet/Testnet Giver/#preparation","text":"","title":"Preparation"},{"location":"2. SDK/TON Labs Testnet/Testnet Giver/#prerequisites","text":"Install the latest version of Docker . See installation tips in the screenshots below: For Linux users, make sure that you are able to run docker as non-root user (see https://docs.docker.com/install/linux/linux-postinstall/ ); Tip : check this page for more Docker installation options https://phoenixnap.com/kb/how-to-install-docker-on-ubuntu-18-04 . Install Node.js 10.x or newer. Make sure that Docker daemon is running on your computer. To check its status, call docker ps . Note that it is recommended to have at least 2Gb of RAM to use Node SE efficiently.","title":"Prerequisites"},{"location":"2. SDK/TON Labs Testnet/Testnet Giver/#basic-installation","text":"This is the easiest version. You can only call three commands to install the solution. First, install TON Labs CLI by running: npm install -g ton-dev-cli Important : If you get errors related to permissions when trying to install packages globally, you can try to fix them using the following options: https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally . Or call: sudo chown -R $(whoami) $(npm root -g) If you fail, run the command under sudo . Then setup your machine. The step is optional, because tondev start and tondev sol perform the step on demand (see below). tondev setup","title":"Basic Installation"},{"location":"2. SDK/TON Labs Testnet/Testnet Giver/#run-the-local-node","text":"Call the following command to run the local node instance (Node SE): tondev start","title":"Run the Local Node"},{"location":"2. SDK/TON Labs Testnet/Testnet Giver/#manual-installation","text":"If you have troubles with tondev CLI utility you can install all required components yourself with the following commands: Note that Windows and Linux use different slashes ( / vs. * * ) for system paths. Make sure to change them as needed in the paths to avoid errors. docker pull tonlabs/local-node docker pull tonlabs/compilers docker create -e USER_AGREEMENT=yes --name tonlabs-local-node -i -p80:80 tonlabs/local-node mkdir user home directory /.tonlabs/compilers/projects docker create -e USER_AGREEMENT=yes --name tonlabs-compilers -it --mount type=bind,dst=/projects,src= user home directory /.tonlabs/compilers/projects tonlabs/compilers docker start tonlabs-local-node docker start tonlabs-compilers Home directory may have one of the following formats: Windows: C:\\Users\\User1 MacOS: '/Users/johnDough' Linux: /home/johnDough \u200b","title":"Manual Installation"},{"location":"2. SDK/TON Labs Testnet/Testnet Giver/#install-client-libraries","text":"Tip : go to the Getting Started section, to create your own environment and a test project from scratch according to detailed guidelines.","title":"Install Client Libraries"},{"location":"2. SDK/TON Labs Testnet/Testnet Giver/#rust","text":"Add a dependency into your cargo manifest: [dependencies] ton-client-rs = 0.11.1 Call the following command: cargo update","title":"Rust"},{"location":"2. SDK/TON Labs Testnet/Testnet Giver/#nodejs","text":"Call the following command to install Node.js client library (the recommended version comes first): dependencies : { ton-client-node-js : ^0.12.1 } Then execute (in the project folder): ~/ton-dev/hello$ npm install Or instead of steps 1 and 2 call: npm install ton-client-node-js","title":"Node.js"},{"location":"2. SDK/TON Labs Testnet/Testnet Giver/#web","text":"Call the following command to install client library for web browsers: npm install ton-client-web-js","title":"Web"},{"location":"2. SDK/TON Labs Testnet/Testnet Giver/#react-native","text":"Call the following command to install client library for React Native: npm install ton-client-react-native-js Visit TON Dev for additional product, company community info.","title":"React Native"},{"location":"3. TON Blockchain/Gal Calculation Basics/","text":"Gas Calculation Basics TON Gas Implementation Specification Overview The entire state of TVM consists of the five components: stack control registers current continuation current codepage gas limits Collectively these are called SCCCG. The Gas component limits gas usage and \u0441ontains four signed 64-bit integers: the remaining gas: gr the current gas limit: gl the maximal gas limit: gm the gas credit: gc . The following is always true: 0 \u2264 gl \u2264 gm, gc \u2265 0, and gr \u2264 gl + gc gc is initialized by zero for internal messages, gr is initialized by gl + gc and gradually decreases, as the TVM runs. When gr becomes negative or if contract terminates with gc 0 , an out of gas exception is triggered. According to the original TON, for most primitives gas is calculated according to the following formula: Pb := 10 + b where b is the instruction length in bits. The same is true for TON Labs implementation. Apart from integer constants, the following expressions may appear: The total price of loading cells. Currently it is 100 gas units per cell. The total price of creating new Cells from Builders. Currently it is 500 gas units. Exception throwing. 50 gas units per exception. Tuple gas price. 1 gas unit for every tuple element. The usage of these additional integers remains unclear now. Research is underway. Global gas limits Global gas limits are values stored in the masterchain configuration contract. Global values are standard and do not change at contract deployment. Only validator consensus can modify them. The following values are now used for shardchains: Global_gas_price = 1000 Global_gas_limit = 1000000 Global_gas_credit = 10000 Global_block_gas_limit = 10000000 Gas-related TVM primitives These is the list of official TVM primitives used for gas-related operations: F800 \u2014 ACCEPT, sets current gas limit gl to its maximal allowed value gm, and resets the gas credit gc to zero, decreasing the value of gr by gc in the process. In other words, the current smart contract agrees to buy some gas to finish the current transaction. This action is required to process external messages, which bring no value (hence no gas) with themselves. F801 \u2014 SETGASLIMIT (g \u2013 ), sets current gas limit gl to the minimum of g and gm, and resets the gas credit gc to zero. If the gas consumed so far (including the present instruction) exceeds the resulting value of gl , an (unhandled) out of gas exception is thrown before setting new gas limits. Notice that SETGASLIMIT with an argument g \u2265 2 63 \u2212 1 is equivalent to ACCEPT. F802 \u2014 BUYGAS (x \u2013 ), computes the amount of gas that can be bought for x nanograms, and sets gl accordingly in the same way as SETGASLIMIT. F804 \u2014 GRAMTOGAS (x \u2013 g), computes the amount of gas that can be bought for x nanograms. If x is negative, returns 0. If g exceeds 2 63\u22121, it is replaced with this value. F805 \u2014 GASTOGRAM (g \u2013 x), computes the price of g gas in nanograms. F806\u2013F80F \u2014 Reserved for gas-related primitives. These are yet to be released. All of the above are operational in the TON TVM implementation. TON Labs Implementation The general gas formula is the same as specified by TON specifications. Overall, TON Labs nodes operate in compliance with the specification. For every executed primitive, the amount of gas is added to the virtual machine according to the specification formula. Gas value for every primitive is based on gr . Gas initialization types 1. Calling contract from another contract An internal message with a balance value is received. In this case, the following formulas are applied to determine limits: gm = min(account balance / gas price, global_gas_limit) gl = min(message value / gas price, global_gas_limit) gc = 0 gr = gc + gl By default gas costs are allocated to the caller contract that triggers the transaction with a message. Accepting is also available for internal contracts. If ACCEPT is not called, gas is taken from the caller contract according to the message value. In other words, the message value defines the current limit. The message value determines the starting TVM gas limit. So, to put it plain, if ACCEPT is not called, the message pays, if ACCEPT is used, additional gas can be bought by the target contract. This approach enables flexible contract design where either total gas is paid by the caller contract (but in this case it has to have enough gas at any moment of time) or the target contract also incurs costs. 2. Offchain contract call External messages do not carry balance values. In this case, the values are calculated according to the following formulas: gm = min(account balance / gas price, global_gas_limit) gl = 0 gc = min(gm, global_gas_credit) gr = gc + gl As external messages have no gas value, gas is credited to execute it. Target contracts have to cover costs by calling Accept to buy gas. If a contract returns an exception before the credit is given, no gas fee applies As the public code for node has just been released this documentation is likely to be updated.","title":"Gas Calculation Basics"},{"location":"3. TON Blockchain/Gal Calculation Basics/#gas-calculation-basics","text":"","title":"Gas Calculation Basics"},{"location":"3. TON Blockchain/Gal Calculation Basics/#ton-gas-implementation","text":"","title":"TON Gas Implementation"},{"location":"3. TON Blockchain/Gal Calculation Basics/#specification-overview","text":"The entire state of TVM consists of the five components: stack control registers current continuation current codepage gas limits Collectively these are called SCCCG. The Gas component limits gas usage and \u0441ontains four signed 64-bit integers: the remaining gas: gr the current gas limit: gl the maximal gas limit: gm the gas credit: gc . The following is always true: 0 \u2264 gl \u2264 gm, gc \u2265 0, and gr \u2264 gl + gc gc is initialized by zero for internal messages, gr is initialized by gl + gc and gradually decreases, as the TVM runs. When gr becomes negative or if contract terminates with gc 0 , an out of gas exception is triggered. According to the original TON, for most primitives gas is calculated according to the following formula: Pb := 10 + b where b is the instruction length in bits. The same is true for TON Labs implementation. Apart from integer constants, the following expressions may appear: The total price of loading cells. Currently it is 100 gas units per cell. The total price of creating new Cells from Builders. Currently it is 500 gas units. Exception throwing. 50 gas units per exception. Tuple gas price. 1 gas unit for every tuple element. The usage of these additional integers remains unclear now. Research is underway.","title":"Specification Overview"},{"location":"3. TON Blockchain/Gal Calculation Basics/#global-gas-limits","text":"Global gas limits are values stored in the masterchain configuration contract. Global values are standard and do not change at contract deployment. Only validator consensus can modify them. The following values are now used for shardchains: Global_gas_price = 1000 Global_gas_limit = 1000000 Global_gas_credit = 10000 Global_block_gas_limit = 10000000","title":"Global gas limits"},{"location":"3. TON Blockchain/Gal Calculation Basics/#gas-related-tvm-primitives","text":"These is the list of official TVM primitives used for gas-related operations: F800 \u2014 ACCEPT, sets current gas limit gl to its maximal allowed value gm, and resets the gas credit gc to zero, decreasing the value of gr by gc in the process. In other words, the current smart contract agrees to buy some gas to finish the current transaction. This action is required to process external messages, which bring no value (hence no gas) with themselves. F801 \u2014 SETGASLIMIT (g \u2013 ), sets current gas limit gl to the minimum of g and gm, and resets the gas credit gc to zero. If the gas consumed so far (including the present instruction) exceeds the resulting value of gl , an (unhandled) out of gas exception is thrown before setting new gas limits. Notice that SETGASLIMIT with an argument g \u2265 2 63 \u2212 1 is equivalent to ACCEPT. F802 \u2014 BUYGAS (x \u2013 ), computes the amount of gas that can be bought for x nanograms, and sets gl accordingly in the same way as SETGASLIMIT. F804 \u2014 GRAMTOGAS (x \u2013 g), computes the amount of gas that can be bought for x nanograms. If x is negative, returns 0. If g exceeds 2 63\u22121, it is replaced with this value. F805 \u2014 GASTOGRAM (g \u2013 x), computes the price of g gas in nanograms. F806\u2013F80F \u2014 Reserved for gas-related primitives. These are yet to be released. All of the above are operational in the TON TVM implementation.","title":"Gas-related TVM primitives"},{"location":"3. TON Blockchain/Gal Calculation Basics/#ton-labs-implementation","text":"The general gas formula is the same as specified by TON specifications. Overall, TON Labs nodes operate in compliance with the specification. For every executed primitive, the amount of gas is added to the virtual machine according to the specification formula. Gas value for every primitive is based on gr .","title":"TON Labs Implementation"},{"location":"3. TON Blockchain/Gal Calculation Basics/#gas-initialization-types","text":"1. Calling contract from another contract An internal message with a balance value is received. In this case, the following formulas are applied to determine limits: gm = min(account balance / gas price, global_gas_limit) gl = min(message value / gas price, global_gas_limit) gc = 0 gr = gc + gl By default gas costs are allocated to the caller contract that triggers the transaction with a message. Accepting is also available for internal contracts. If ACCEPT is not called, gas is taken from the caller contract according to the message value. In other words, the message value defines the current limit. The message value determines the starting TVM gas limit. So, to put it plain, if ACCEPT is not called, the message pays, if ACCEPT is used, additional gas can be bought by the target contract. This approach enables flexible contract design where either total gas is paid by the caller contract (but in this case it has to have enough gas at any moment of time) or the target contract also incurs costs. 2. Offchain contract call External messages do not carry balance values. In this case, the values are calculated according to the following formulas: gm = min(account balance / gas price, global_gas_limit) gl = 0 gc = min(gm, global_gas_credit) gr = gc + gl As external messages have no gas value, gas is credited to execute it. Target contracts have to cover costs by calling Accept to buy gas. If a contract returns an exception before the credit is given, no gas fee applies As the public code for node has just been released this documentation is likely to be updated.","title":"Gas initialization types"},{"location":"3. TON Blockchain/Replay Attack Protection/","text":"Replay Attack Protection All external messages must be protected against replay attacks. Otherwise, a malicious party can resend an external message obtained from blockchain and repeat a transaction for a smart contract. For example, a hacker can repeat a Gram transfer and bring an account balance to zero. For internal messages the risk of replay attacks is irrelevant, as they only can be generated inside blockchain by other contracts. Implementation Options Different approaches to implementing replay attack protection exist. None of them is a silver bullet, but there are several indicators applied to compare and evaluate them: Gas consumption Storage fees Race condition Usability Sequence number This is a very simple protection option. It implies that each protected contract stores a counter (i.e. 32bit integer) that is initially set to zero. An external message is then accepted by the contract only under condition that it contains a number equal to the current contract counter value. Each time a new message is accepted, the contract counter value is incremented by one. Pros: simple implementation in contracts; low gas and storage fees; Cons: To get the right sequence number off-chain, a client must request the contract state from blockchain before sending an external message. If the state is large, it can cause a network traffic overhead; Race condition issue that arises when there are multiple contract owners who can simultaneously call it. One owner can increment the contract counter value before this counter becomes available to the next owner; Less sensitive issue of a potential counter overflow in the future. In this case the TVM will throw an exception causing the owner to lose access to the contract. Timestamp Another simple protection option is adding a timestamp to every external message. It can be a 64-bit value in unixtime format. The contract must store the timestamp of the last accepted external message. When a new external message comes, the contract verifies the message timestamp. It must to be bigger than the previous message timestamp and less then now + interval . The interval value is necessary, because now does not stand for the current time, but indicates creation time of the relevant block. The interval can be equal the block generation period or bigger. Pros: very simple implementation; No need to request account state before sending external messages. Cons: Race condition issues remains unresolved as in case of sequence number implementation; Client time must be synchronized with blockchain time. Set of accepted messages Dictionary of randoms This option implies that every external message contains a random value, for example, a 32bit integer. A protected contract, in turn, stores previously used randoms in a dictionary, compares message randoms with it and rejects a message if there is a match detected. Pros: no need to request account state before sending an external message; No race condition; simultaneous access to contract of multiple parties is supported. Collisions are still possible when multiple clients have the same random, but chances can be minimized. Cons: consumes a lot of gas for dictionary write/read operations. Note that the gas fee will increase in the future; high storage fees for storing dictionary. Dictionary of messages with garbage collection This option implies that every external message contains an ' expire-at ' integer that defines the time when the message becomes invalid (i.e. expires). The contract, in turn, must store a dictionary with all recently accepted and not expired external messages. The key is a message hash, the value is the relevant 'expire-at' integer. The contract then rejects all messages that are already present in its dictionary. To avoid persistent data increase, a protected contract can delete messages with the expire-at value less than now from its dictionary. Pros: no need to request the account state before sending an external message; No race condition issues. Cons: Harder to implement compared to the above option with a dictionary of randoms; High gas fees caused by the need to access a dictionary; High storage fees, yet these can be reduced by deleting expired messages from the dictionary; Garbage collecting also involves some gas costs. Sessions Before sending requests to contract, a user creates a session with a contract by sending a create_session external message. The message contains a new session ID, its expired-at time and a starting sequence number. The contract stores a session dictionary. After a session is created, the user adds the session_id and the next session sequence number to every external message. For every external message (not create_session ) the contract checks that: the message session ID exists in dictionary the message sequence number is equal to the stored session number, and the now value is less then the expired-at value for session If all checks are passed successfully, the contract increments the stored sequence number for the session. In case of failure, the message is rejected. Also, expired sessions require some garbage collection. Pros: No need to request the account state before sending an external message; No race condition issues; No collisions. Cons: Harder to implement compared to all the options covered above; High gas fees; High storage fees; Need to use garbage collecting; Unsuitable for simple single-user contracts. Conclusion In TON Labs, we selected a lightweight and simple replay protection option; it will be implemented in the compiler by default and based on the timestamp approach. It is supposed to work well for single-user contracts, as well as for contracts without heavy race conditions. It is easy to use given that TON Labs SDK enables inserting a timestamp automatically on the client side. Also, there will be an option to redefine the default protection method by overloading a special contract function. This is how contract developers will be able to implement any protection option they seem fit.","title":"Replay Attack Protection"},{"location":"3. TON Blockchain/Replay Attack Protection/#replay-attack-protection","text":"All external messages must be protected against replay attacks. Otherwise, a malicious party can resend an external message obtained from blockchain and repeat a transaction for a smart contract. For example, a hacker can repeat a Gram transfer and bring an account balance to zero. For internal messages the risk of replay attacks is irrelevant, as they only can be generated inside blockchain by other contracts.","title":"Replay Attack Protection"},{"location":"3. TON Blockchain/Replay Attack Protection/#implementation-options","text":"Different approaches to implementing replay attack protection exist. None of them is a silver bullet, but there are several indicators applied to compare and evaluate them: Gas consumption Storage fees Race condition Usability","title":"Implementation Options"},{"location":"3. TON Blockchain/Replay Attack Protection/#sequence-number","text":"This is a very simple protection option. It implies that each protected contract stores a counter (i.e. 32bit integer) that is initially set to zero. An external message is then accepted by the contract only under condition that it contains a number equal to the current contract counter value. Each time a new message is accepted, the contract counter value is incremented by one. Pros: simple implementation in contracts; low gas and storage fees; Cons: To get the right sequence number off-chain, a client must request the contract state from blockchain before sending an external message. If the state is large, it can cause a network traffic overhead; Race condition issue that arises when there are multiple contract owners who can simultaneously call it. One owner can increment the contract counter value before this counter becomes available to the next owner; Less sensitive issue of a potential counter overflow in the future. In this case the TVM will throw an exception causing the owner to lose access to the contract.","title":"Sequence number"},{"location":"3. TON Blockchain/Replay Attack Protection/#timestamp","text":"Another simple protection option is adding a timestamp to every external message. It can be a 64-bit value in unixtime format. The contract must store the timestamp of the last accepted external message. When a new external message comes, the contract verifies the message timestamp. It must to be bigger than the previous message timestamp and less then now + interval . The interval value is necessary, because now does not stand for the current time, but indicates creation time of the relevant block. The interval can be equal the block generation period or bigger. Pros: very simple implementation; No need to request account state before sending external messages. Cons: Race condition issues remains unresolved as in case of sequence number implementation; Client time must be synchronized with blockchain time.","title":"Timestamp"},{"location":"3. TON Blockchain/Replay Attack Protection/#set-of-accepted-messages","text":"Dictionary of randoms This option implies that every external message contains a random value, for example, a 32bit integer. A protected contract, in turn, stores previously used randoms in a dictionary, compares message randoms with it and rejects a message if there is a match detected. Pros: no need to request account state before sending an external message; No race condition; simultaneous access to contract of multiple parties is supported. Collisions are still possible when multiple clients have the same random, but chances can be minimized. Cons: consumes a lot of gas for dictionary write/read operations. Note that the gas fee will increase in the future; high storage fees for storing dictionary. Dictionary of messages with garbage collection This option implies that every external message contains an ' expire-at ' integer that defines the time when the message becomes invalid (i.e. expires). The contract, in turn, must store a dictionary with all recently accepted and not expired external messages. The key is a message hash, the value is the relevant 'expire-at' integer. The contract then rejects all messages that are already present in its dictionary. To avoid persistent data increase, a protected contract can delete messages with the expire-at value less than now from its dictionary. Pros: no need to request the account state before sending an external message; No race condition issues. Cons: Harder to implement compared to the above option with a dictionary of randoms; High gas fees caused by the need to access a dictionary; High storage fees, yet these can be reduced by deleting expired messages from the dictionary; Garbage collecting also involves some gas costs.","title":"Set of accepted messages"},{"location":"3. TON Blockchain/Replay Attack Protection/#sessions","text":"Before sending requests to contract, a user creates a session with a contract by sending a create_session external message. The message contains a new session ID, its expired-at time and a starting sequence number. The contract stores a session dictionary. After a session is created, the user adds the session_id and the next session sequence number to every external message. For every external message (not create_session ) the contract checks that: the message session ID exists in dictionary the message sequence number is equal to the stored session number, and the now value is less then the expired-at value for session If all checks are passed successfully, the contract increments the stored sequence number for the session. In case of failure, the message is rejected. Also, expired sessions require some garbage collection. Pros: No need to request the account state before sending an external message; No race condition issues; No collisions. Cons: Harder to implement compared to all the options covered above; High gas fees; High storage fees; Need to use garbage collecting; Unsuitable for simple single-user contracts.","title":"Sessions"},{"location":"3. TON Blockchain/Replay Attack Protection/#conclusion","text":"In TON Labs, we selected a lightweight and simple replay protection option; it will be implemented in the compiler by default and based on the timestamp approach. It is supposed to work well for single-user contracts, as well as for contracts without heavy race conditions. It is easy to use given that TON Labs SDK enables inserting a timestamp automatically on the client side. Also, there will be an option to redefine the default protection method by overloading a special contract function. This is how contract developers will be able to implement any protection option they seem fit.","title":"Conclusion"},{"location":"3. TON Blockchain/Storage Fee Calculation/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"3. TON Blockchain/Storage Fee Calculation/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"3. TON Blockchain/Storage Fee Calculation/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"3. TON Blockchain/Storage Fee Calculation/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"3. TON Blockchain/TVM Error Codes/","text":"TVM Error Codes 0 TVM terminated successfully 1 TVM terminated successfully: alternative code 2 Stack underflow 3 Stack overflow 4 Integer overflow 5 Range check error 6 Invalid opcode 7 Type check error 8 Cell overflow 9 Cell underflow 10 Dictionary error 11 Unknown error 12 Fatal error 13 Out of gas: the contract is either low on gas, or its limit is exceeded","title":"TVM Error Codes"},{"location":"3. TON Blockchain/TVM Error Codes/#tvm-error-codes","text":"0 TVM terminated successfully 1 TVM terminated successfully: alternative code 2 Stack underflow 3 Stack overflow 4 Integer overflow 5 Range check error 6 Invalid opcode 7 Type check error 8 Cell overflow 9 Cell underflow 10 Dictionary error 11 Unknown error 12 Fatal error 13 Out of gas: the contract is either low on gas, or its limit is exceeded","title":"TVM Error Codes"},{"location":"4. FAQ/","text":"TON Dev Documentation TBD","title":"TON Dev Documentation"},{"location":"4. FAQ/#ton-dev-documentation","text":"TBD","title":"TON Dev Documentation"},{"location":"4. FAQ/SDK and Integration/","text":"SDK and Integration Q : Would you be able to point me to where BOC messages are created or signed inside the JavaScript or Rust SDK? In the JS SDK, I just see that all calls end up hitting this.requestLibrary with some library specified, and that looks like it ends up calling a TONClientLibrary module, but it's not clear where these libraries actually exist (they seem to be on the node itself). A : BOC messages are created and signed inside the Rust SDK library. The library is located at the client side. For the Node.js SDK client, the native Node.js addon is used. For React Native, there is a native library for target platform where the client application is running. For the Web client, there is the Web Assembly module downloaded and executed at the client device. The Rust SDK library contains core SDK functions used on all platforms. The SDK will be available as Open Source and more platform and language rappers are to be developed. We are open to customer and community suggestions and contributions to the repository, once it is open. Q : Don\u2019t see any code in the SDK's that is actually generating keys locally or constructing .boc messages. It seems they are just calling your node to do that for them, so it seems like more of a client to the node. Please correct me if that\u2019s not right. A : See the previous answer. Keys are generated in the Rust core library running on a client device. The message BOC construction code is also located there. The SDK's interaction with the node is limited to sending external blockchain messages calling contracts and querying results from the GraphQL server. All crypto operations are performed locally. Q : Is there an API call to the full node that returns a given account\u2019s balance along with the block height at which that balance was calculated, in a single API call? Note: This IS NOT the same thing as historical balance lookup. (Example: GET /balance/account1 - {balance:10, height: 123902}) The current account state provided by the lite-client does not include this information. Can we be given this information if it is not available today? A : It is possible to get this information by the series of graphQL queries: query an account by its ID (address) and remember last_trans_lt (last transaction logical time) query { accounts(filter: {id: {eq: 0000000000000000000000000000000000000000000000000000000000000000 }}) { id, storage {last_trans_lt} } } result: { data : { accounts : [ { id : 0000000000000000000000000000000000000000000000000000000000000000 , storage : { last_trans_lt : 4 } } ] } } query the transaction with your account ID and the logical time; remember the corresponding block_id query { transactions(filter: { account_addr: {eq: 0000000000000000000000000000000000000000000000000000000000000000 } lt: {eq: 4} }) { id, block_id } } result: { data : { transactions : [ { id : 3badb9e5707db8e61e0e335e02eacb6df2a118512791b620c73a71d826e840c3 , block_id : 4a8537f7499e122fc539b6250cd70168e80a129dcd684de6d0928d86105cf430 } ] } } query a block by an ID with the required data: query { blocks(filter: { id: {eq: 4a8537f7499e122fc539b6250cd70168e80a129dcd684de6d0928d86105cf430 } }) { id, info { seq_no } } } result: { data : { blocks : [ { id : 4a8537f7499e122fc539b6250cd70168e80a129dcd684de6d0928d86105cf430 , info : { seq_no : 1 } } ] } } Q : Does your node currently (or will you) provide an API to submit pre-signed messages (e.g. a pre-signed bag-of-cells message)? Can we have this endpoint (not a CLI interface) if it does not exist today? A : To send pre-generated messages, use the processMessage function of the SDK JS client. Also, there will be a function to construct unsigned messages. You will be able to sign generated message yourself and then to send it using the SDK. For example you can generate message to call the contract by SDK function. That function returns a serialized message and its hash to be signed. You sign it using your own implementation of the signature algorithm (or using some hardware security module). Then you call another SDK function that adds your signature to the message generated at first step. Finally, the resulting signed message can be sent by processMessage function. Q : How does one derive the message (or transaction) hash from a signed bag-of-cells message to a contract? Can you provide details on how we can compute this on our own? (Ideally we can compute this so we can look it up after submitting to the network.) A : The SDK returns hash of the generated message as a message ID. We will provide a function which will return hash for a specific message in the next few weeks. To calculate hash manually, deserialize the bag of cells into a tree of cells and calculate the representation hash of the root cell as described in paragraph 3.1.5 of the original TVM specification. It's quite an effort, though. Q : It seems that messages are not replay protected on their own. Is this the case? Is there any default replay protection provided by the network or must every contract implement their own sequence number or similar method to replay protection? A : There is no default replay attack protection in TON. A contract developer is supposed to implement it manually. There are only \"best practices\" by TON developers here . TON Labs compilers will have a default inline implementation of replay protection. Q : Can you provide more explicit details or provide an example of how an account\u2019s address is derived from the compiled contract and initial state and specifically how that hash is computed and over what components? Source code is also helpful here if you can provide it. A : A blockchain account contains the State Init field. It stores the contract code and persisted data. State init is also tree of cells. At contract deployment this field is transferred alongside the deploying message (so called constructor message) and is set as the contract initial state. The representation hash (see paragraph 3.1.5 of the TVM specification) of the contract initial state is the account address. The node checks that the state init hash of the deployment message is equal to the destination address. The SDK will have a function for computing account address by its initial state. The SDK source code will be available soon. Q : Is (or will be) the solidity-to-tvm and tvm-linker source code available to users? If not, can agreements be signed to make it available to partners? A : Yes, both Sol2Tvm compiler and TVM-Linker will be available as open source. Q : With a Solidity contract, how does one properly specify an address parameter? In solidity, addresses are uint256 but this can only capture the address portion and not the workchain_id. How would one specify the full address parameter correctly here? (e.g. \u201c0:D702CC0414858D83A5538A3C1C86231872F006453AF7C825A59F9DD12D636AF\u201d is invalid in solidity for an address param) A : Now we only use the address field of MsgAddressInt structure as Solidity address type. We assume that worckchain_id is 0. But in future the address type will represent the whole MsgAddressInt structure. Now workchain_id can be defined separately as int8. Q : When deploying a contract init message that was created using a solidity contract, the Sol2TVM compiler and tvm_linker, I\u2019m seeing the init succeed initially but then also get replayed dozens of times after. How does one replay protect a contract init message for a solidity-compiled contract? (example message that was replayed after the initialization was already successful previously: ) A : The sample message at has no init (it is init:nothing ), and a transaction with this message is aborted. But in general, the StateInit data attached to a message is used by the node only once: when a contract is in the Uninit state. Replays of such message can succeed, but the contract code will not be changed. An Init msg created with sol2tvm compiler and tvm_linker contains an encoded constructor call. Now you can call constructor multiple times, but in future releases it will be changed.","title":"SDK and Integration"},{"location":"4. FAQ/SDK and Integration/#sdk-and-integration","text":"Q : Would you be able to point me to where BOC messages are created or signed inside the JavaScript or Rust SDK? In the JS SDK, I just see that all calls end up hitting this.requestLibrary with some library specified, and that looks like it ends up calling a TONClientLibrary module, but it's not clear where these libraries actually exist (they seem to be on the node itself). A : BOC messages are created and signed inside the Rust SDK library. The library is located at the client side. For the Node.js SDK client, the native Node.js addon is used. For React Native, there is a native library for target platform where the client application is running. For the Web client, there is the Web Assembly module downloaded and executed at the client device. The Rust SDK library contains core SDK functions used on all platforms. The SDK will be available as Open Source and more platform and language rappers are to be developed. We are open to customer and community suggestions and contributions to the repository, once it is open. Q : Don\u2019t see any code in the SDK's that is actually generating keys locally or constructing .boc messages. It seems they are just calling your node to do that for them, so it seems like more of a client to the node. Please correct me if that\u2019s not right. A : See the previous answer. Keys are generated in the Rust core library running on a client device. The message BOC construction code is also located there. The SDK's interaction with the node is limited to sending external blockchain messages calling contracts and querying results from the GraphQL server. All crypto operations are performed locally. Q : Is there an API call to the full node that returns a given account\u2019s balance along with the block height at which that balance was calculated, in a single API call? Note: This IS NOT the same thing as historical balance lookup. (Example: GET /balance/account1 - {balance:10, height: 123902}) The current account state provided by the lite-client does not include this information. Can we be given this information if it is not available today? A : It is possible to get this information by the series of graphQL queries: query an account by its ID (address) and remember last_trans_lt (last transaction logical time) query { accounts(filter: {id: {eq: 0000000000000000000000000000000000000000000000000000000000000000 }}) { id, storage {last_trans_lt} } } result: { data : { accounts : [ { id : 0000000000000000000000000000000000000000000000000000000000000000 , storage : { last_trans_lt : 4 } } ] } } query the transaction with your account ID and the logical time; remember the corresponding block_id query { transactions(filter: { account_addr: {eq: 0000000000000000000000000000000000000000000000000000000000000000 } lt: {eq: 4} }) { id, block_id } } result: { data : { transactions : [ { id : 3badb9e5707db8e61e0e335e02eacb6df2a118512791b620c73a71d826e840c3 , block_id : 4a8537f7499e122fc539b6250cd70168e80a129dcd684de6d0928d86105cf430 } ] } } query a block by an ID with the required data: query { blocks(filter: { id: {eq: 4a8537f7499e122fc539b6250cd70168e80a129dcd684de6d0928d86105cf430 } }) { id, info { seq_no } } } result: { data : { blocks : [ { id : 4a8537f7499e122fc539b6250cd70168e80a129dcd684de6d0928d86105cf430 , info : { seq_no : 1 } } ] } } Q : Does your node currently (or will you) provide an API to submit pre-signed messages (e.g. a pre-signed bag-of-cells message)? Can we have this endpoint (not a CLI interface) if it does not exist today? A : To send pre-generated messages, use the processMessage function of the SDK JS client. Also, there will be a function to construct unsigned messages. You will be able to sign generated message yourself and then to send it using the SDK. For example you can generate message to call the contract by SDK function. That function returns a serialized message and its hash to be signed. You sign it using your own implementation of the signature algorithm (or using some hardware security module). Then you call another SDK function that adds your signature to the message generated at first step. Finally, the resulting signed message can be sent by processMessage function. Q : How does one derive the message (or transaction) hash from a signed bag-of-cells message to a contract? Can you provide details on how we can compute this on our own? (Ideally we can compute this so we can look it up after submitting to the network.) A : The SDK returns hash of the generated message as a message ID. We will provide a function which will return hash for a specific message in the next few weeks. To calculate hash manually, deserialize the bag of cells into a tree of cells and calculate the representation hash of the root cell as described in paragraph 3.1.5 of the original TVM specification. It's quite an effort, though. Q : It seems that messages are not replay protected on their own. Is this the case? Is there any default replay protection provided by the network or must every contract implement their own sequence number or similar method to replay protection? A : There is no default replay attack protection in TON. A contract developer is supposed to implement it manually. There are only \"best practices\" by TON developers here . TON Labs compilers will have a default inline implementation of replay protection. Q : Can you provide more explicit details or provide an example of how an account\u2019s address is derived from the compiled contract and initial state and specifically how that hash is computed and over what components? Source code is also helpful here if you can provide it. A : A blockchain account contains the State Init field. It stores the contract code and persisted data. State init is also tree of cells. At contract deployment this field is transferred alongside the deploying message (so called constructor message) and is set as the contract initial state. The representation hash (see paragraph 3.1.5 of the TVM specification) of the contract initial state is the account address. The node checks that the state init hash of the deployment message is equal to the destination address. The SDK will have a function for computing account address by its initial state. The SDK source code will be available soon. Q : Is (or will be) the solidity-to-tvm and tvm-linker source code available to users? If not, can agreements be signed to make it available to partners? A : Yes, both Sol2Tvm compiler and TVM-Linker will be available as open source. Q : With a Solidity contract, how does one properly specify an address parameter? In solidity, addresses are uint256 but this can only capture the address portion and not the workchain_id. How would one specify the full address parameter correctly here? (e.g. \u201c0:D702CC0414858D83A5538A3C1C86231872F006453AF7C825A59F9DD12D636AF\u201d is invalid in solidity for an address param) A : Now we only use the address field of MsgAddressInt structure as Solidity address type. We assume that worckchain_id is 0. But in future the address type will represent the whole MsgAddressInt structure. Now workchain_id can be defined separately as int8. Q : When deploying a contract init message that was created using a solidity contract, the Sol2TVM compiler and tvm_linker, I\u2019m seeing the init succeed initially but then also get replayed dozens of times after. How does one replay protect a contract init message for a solidity-compiled contract? (example message that was replayed after the initialization was already successful previously: ) A : The sample message at has no init (it is init:nothing ), and a transaction with this message is aborted. But in general, the StateInit data attached to a message is used by the node only once: when a contract is in the Uninit state. Replays of such message can succeed, but the contract code will not be changed. An Init msg created with sol2tvm compiler and tvm_linker contains an encoded constructor call. Now you can call constructor multiple times, but in future releases it will be changed.","title":"SDK and Integration"},{"location":"4. FAQ/Smart Contracts/","text":"Smart Contracts *Q : Based on your documentation and the white paper, there is a gas limit on transactions/transfers but this is not set by the sender but is a function of the transfer amount or contract balance. Do senders/contracts have any ability to set an upper limit on the gas consumed by a transaction A : contracts can set upper gas limit in msg.value (in nanograms), but receiver contract can increase this limit buying more gas (accept cmd). We cannot set gas limit for external messages; it is automatically calculated as minimal contract balance or global gas limit per transaction. Q : Do you have any insight into the various send modes for SENDRAWMSG ? I'm trying to understand failure scenarios and if that call fails when mode=0 , then the internal contract state fails to update and we risk the failed message being replayed until the account is drained. mode=2 is supposed to \"ignore errors\" such that the contract state will get updated even if the msg fails to send. But by changing the mode to 2 I'm now seeing some additional fees taken out of my transfer amount (specifically my transfer amt is reduced by 0.001 Grams which is the total_fwd_fee ) Do you have any insight here? A : Forward fees reduce transfer amount even if mode=0; these are always present in internal messages.","title":"Smart Contracts"},{"location":"4. FAQ/Smart Contracts/#smart-contracts","text":"*Q : Based on your documentation and the white paper, there is a gas limit on transactions/transfers but this is not set by the sender but is a function of the transfer amount or contract balance. Do senders/contracts have any ability to set an upper limit on the gas consumed by a transaction A : contracts can set upper gas limit in msg.value (in nanograms), but receiver contract can increase this limit buying more gas (accept cmd). We cannot set gas limit for external messages; it is automatically calculated as minimal contract balance or global gas limit per transaction. Q : Do you have any insight into the various send modes for SENDRAWMSG ? I'm trying to understand failure scenarios and if that call fails when mode=0 , then the internal contract state fails to update and we risk the failed message being replayed until the account is drained. mode=2 is supposed to \"ignore errors\" such that the contract state will get updated even if the msg fails to send. But by changing the mode to 2 I'm now seeing some additional fees taken out of my transfer amount (specifically my transfer amt is reduced by 0.001 Grams which is the total_fwd_fee ) Do you have any insight here? A : Forward fees reduce transfer amount even if mode=0; these are always present in internal messages.","title":"Smart Contracts"},{"location":"4. FAQ/Solidity Compiler/","text":"Solidity Compiler Q: There are samples of transaction generation via the LLVM Compiler and via the SOL2TVM Compiler. Yet, there is no signing operation in the sample Solidity code. A : Check the contract04.sol example, it demonstrates how to transfer grams with the **address.transfer()** function; Signing is not yet supported, plan to add it in the next release Q: Does Solidity compiler support ecrecover? Now it throws \u201cstd::exception::what: unknown variable: ecrecover\u201d. If not, will there be support soon? There is nothing in the guide about it. A : No, this is an Ethereum-specific operation. But we plan to provide an equivalent, for now use the ABI. Q: Is 'address(this)' operational? A : Only address(this).balance is available at this moment. The address(this) function will be available soon. Q: Can structures be transferred as function parameters? A : Not for public functions. The feature is to be released later. For internal functions, yes, this is possible. Q: The .push method is unavailable. How do I add a new element? A : You can use array[array.length] = new_element;. The .push method will be added later. Q: How an address is formed for a Solidity contract? A : The address of a Solidity smart-contract for TON is deterministic and is computed prior to its deployment. Full address of the contract consists of a 32-bit ID of a workchain the contract is being deployed to and of the 256-bit internal address (or account identifier) inside the chosen workchain. The internal address is a representative hash of the contract initial state. The contract Initial state consists of the contract code serialized according to the TON blockchain specification, section 5.3.10, and its data. Hash computation principles: the hash function applied to the relevant hash code computation is called \"representation hash\". Its detailed description is available in the TON blockchain specification, section 1.1.8. Essentially, the representation hash is sha256 function recursively applied to the storage cell of its argument.","title":"Solidity Compiler"},{"location":"4. FAQ/Solidity Compiler/#solidity-compiler","text":"Q: There are samples of transaction generation via the LLVM Compiler and via the SOL2TVM Compiler. Yet, there is no signing operation in the sample Solidity code. A : Check the contract04.sol example, it demonstrates how to transfer grams with the **address.transfer()** function; Signing is not yet supported, plan to add it in the next release Q: Does Solidity compiler support ecrecover? Now it throws \u201cstd::exception::what: unknown variable: ecrecover\u201d. If not, will there be support soon? There is nothing in the guide about it. A : No, this is an Ethereum-specific operation. But we plan to provide an equivalent, for now use the ABI. Q: Is 'address(this)' operational? A : Only address(this).balance is available at this moment. The address(this) function will be available soon. Q: Can structures be transferred as function parameters? A : Not for public functions. The feature is to be released later. For internal functions, yes, this is possible. Q: The .push method is unavailable. How do I add a new element? A : You can use array[array.length] = new_element;. The .push method will be added later. Q: How an address is formed for a Solidity contract? A : The address of a Solidity smart-contract for TON is deterministic and is computed prior to its deployment. Full address of the contract consists of a 32-bit ID of a workchain the contract is being deployed to and of the 256-bit internal address (or account identifier) inside the chosen workchain. The internal address is a representative hash of the contract initial state. The contract Initial state consists of the contract code serialized according to the TON blockchain specification, section 5.3.10, and its data. Hash computation principles: the hash function applied to the relevant hash code computation is called \"representation hash\". Its detailed description is available in the TON blockchain specification, section 1.1.8. Essentially, the representation hash is sha256 function recursively applied to the storage cell of its argument.","title":"Solidity Compiler"},{"location":"4. FAQ/TON and TVM/","text":"TON and TVM Q: How to deploy a contract to TON testnet if I use your Toolchain? A : Follow the procedure here . If you are a new user, check the related topics as well (Node SE Installation, Deployment). Q: Which messaging format is used in smart contracts? A : TON Labs uses the same message format as specified at ton . org . The message header format is covered in the blockchain whitepaper (ton.pdf clause 2.4.9 ), the message layout is covered by the blockchain specification (tblkch.pdf 3.1.7. ). Q: How is hash calculated? A : Hash calculation principles used in the TON test node are covered in the official TON VM documentation (tvm.pdf clause 3.1.4 -3.1.7 , tblkch.pdf 1.1.4 ). We use another method to calculate the hash of bag of cells, but we get the same result. Q: Is there any standard multisig contract we can use for TON? How can a multisig wallet be implemented in the TON network? A : The standard TON multisig contract specs and source code are unavailable at the moment. Existing open source multisig contracts can be used, but not all Solidity features are supported now by our compiler. Q: Do you have a good way of doing multiple receive addresses for the same wallet? A : Within TON every contract has only one address. You can use your Forwarder.sol contract, but it cannot be compiled with the current compiler version without some fixes. Q: Are wallets supposed to be deployed on the workchain, masterchain or some other chain? A : Any chain will do, but the basic workchain 0 is the recommended option. Masterchain has very high fees. Q: How do fees work? Does a smart contract pay its own fee or is it charged on the caller address? Does the TON use similar concepts of gas price and gas limit? A : Fees are charged on the contract that executes a transaction. There is a storage fee, a gas fee and a fee for sending messages from contracts . TON contracts consume gas (tvm.pdf clause 1.4 , appendix A.1 ) and have gas limits with specific features.","title":"TON and TVM"},{"location":"4. FAQ/TON and TVM/#ton-and-tvm","text":"Q: How to deploy a contract to TON testnet if I use your Toolchain? A : Follow the procedure here . If you are a new user, check the related topics as well (Node SE Installation, Deployment). Q: Which messaging format is used in smart contracts? A : TON Labs uses the same message format as specified at ton . org . The message header format is covered in the blockchain whitepaper (ton.pdf clause 2.4.9 ), the message layout is covered by the blockchain specification (tblkch.pdf 3.1.7. ). Q: How is hash calculated? A : Hash calculation principles used in the TON test node are covered in the official TON VM documentation (tvm.pdf clause 3.1.4 -3.1.7 , tblkch.pdf 1.1.4 ). We use another method to calculate the hash of bag of cells, but we get the same result. Q: Is there any standard multisig contract we can use for TON? How can a multisig wallet be implemented in the TON network? A : The standard TON multisig contract specs and source code are unavailable at the moment. Existing open source multisig contracts can be used, but not all Solidity features are supported now by our compiler. Q: Do you have a good way of doing multiple receive addresses for the same wallet? A : Within TON every contract has only one address. You can use your Forwarder.sol contract, but it cannot be compiled with the current compiler version without some fixes. Q: Are wallets supposed to be deployed on the workchain, masterchain or some other chain? A : Any chain will do, but the basic workchain 0 is the recommended option. Masterchain has very high fees. Q: How do fees work? Does a smart contract pay its own fee or is it charged on the caller address? Does the TON use similar concepts of gas price and gas limit? A : Fees are charged on the contract that executes a transaction. There is a storage fee, a gas fee and a fee for sending messages from contracts . TON contracts consume gas (tvm.pdf clause 1.4 , appendix A.1 ) and have gas limits with specific features.","title":"TON and TVM"},{"location":"5. Misc/Glossary/","text":"The Moonspeak This brief set of terms and definitions is in no way exhaustive or final. It is based on personal experience with blockchain or related concepts and aims at making complex things a little more clear. What makes blockchain talk complicated, is that this rapidly evolving phenomenon pools together multiple concepts, methodologies and ideas from numerous areas and domains from math to behaviorist studies. Considered separately, each item may be clear and logical, but once pooled together and interwoven, they are not easy to define and describe in plain well-structured phrases. For example, explanation of the root term - Blockchain - can start from the basic notion of database, but just as well we can choose P2P networks as the starting place. Bringing both together within a single definition makes it long and more confusing. But we keep on trying. Hope you will have a good time reading it. Feedback and suggestions are welcome. B Blockchain Blockchain is basically a database for storing transactions packed in blocks. Blockchain has some technical particularities that make it ideal for fintech services but quite awkward for general DB uses: data in blockchain cannot be changed (i.e. transactions are unchangeable), all data is linked to its owner, all data meets some mandatory rules (i.e. it is consistent) and, ta-da, its decentralized. Blockchains rely on peer-to-peer interaction and require no third-party regulation, control or coordination. To ensure fairness, there is consensus (validation procedures that enable mining) and encryption technologies. Another, broader, term for this type of databases is Distributed Ledger. Tip : for further reading we would suggesting articles about peer-to-peer networks, sharding, workchains, multi-chain models. C Cold Wallet Cold wallet (aka hardware wallet) is a physical appliance (an nfc-card, a usb drive) where wallet private keys are stored. Cold wallets are considered more secure, as there is no way to hack them. Also, in some cases a cold wallet enables easier and faster access to transactions. For example, with an nfc-card you only have to hover it over the back side of your device to start transactions. No more mess with passwords and pin-codes. Consensus Consensus is a protocol implemented within a blochchain to make sure that its nodes (engines that maintain the blockchain and may process transactions, depending on the architecture) agree on requirements to transactions to validate them. Interestingly, validation enabled crypto-currency mining, as newly mined coins are the reward for validating a transaction. With consensus in place, no centralized regulation is needed to prevent frauds. There are several popular consensus protocols: Proof of Work (PoW), Proof of Stake, Delegated Proof of Stake, etc. New consensus mechanisms evolve to reduce energy consumption associated with the PoW and optimize overall performance. Moreover, consensus without mining is being developed and researched. Crypto-currency Surprise, surprise, but crypto-currency is not necessarily blockchain and blockchain is not necessarily crypto-currency. Technically speaking, to generate crypto-currency one needs a distributed ledger meeting two core requirements: decentralized storage and encryption technology. Yet, blockchain remains the most popular, because it enables mining (i.e. generating new currency units) as a reward for transaction validation thus reducing commissions imposed on the parties. Tip : to dig deeper, you might want to research the related concepts: fiat money, token, burning, mining vs. minting, Byzantine Generals Problem, TenderMint. D Dapp, Decentralized application In short, it is an application (usually fintech) with a blockchain smart-contract behind it to ensure fairness and decentralization. An extended definition though has to cover the infrastructure a bit. A standard app either operates locally (e.g. a single-player game) or uses some standard server-client architecture (e.g. a bank app). In blockchain, every Dapp is basically a smart contract that describes transactions and rules applied to them. Roughly speaking, each smart contract has a server side that is stored in the blockchain and executed by the virtual machine (back-end for machine-to-machine interaction) and the client-side that is available to a user and has a GUI for human to machine interaction (front-end). The two parts interact via messaging (basically, requests to the contract and its responses). The front-end part can be implement in many popular programming languages, most popular are .js and .ts, Python is on the rise. Decentralized economy In the real world anarchy turns out to be a disaster and everybody's business is known to be nobody's business. Communism failed and is dabbed a Utopian concept forever. In the digital world, however, blockchain is the game-changer when it comes to equal rights, fair play, data security, privacy, decentralization, democracy, transparency. You can have it all without any central authority, regulations and dictatorship. Hmm, is it as good as it sounds? Let's see. Booming peer to peer networks with consensus methods allow parties to safely and transparently carry out financial (or other) transactions without any regulator. Being just a technical thing, P2P solutions (in particular, blockchain) have no geographical, social, political or gender bias. N Node Basically, Node is a blockchain server that has a working instance of a virtual machine (VM) and a set of relevant instruments that ensure VM interaction with clients (i.e. for example, with customer applications). Every blockchain platform has its own messaging standards and protocols, let alone VM's, so node architectures differ across platforms. What's more even within a single platform variations may exist, although all nodes have to be compatible within a platform. Visit TON Dev for its Node SE offer. S Smart contract Smart contract is not a legal document, rather, it is a piece of code deployed in blockchain. This code contains an executable sequence of operations. Each operation manipulates some available data (e.g. an account balance), retrieves it and\\or changes it (e.g. transfers an amount). Each instance of smart contract execution is a blockchain transaction with block generation. Smart contract is the core part of each Dapp (roughly speaking, it is its back end). Smart contracts may interact with each other. There are several types of standard smart contracts that implement tokens. The most famous is ERC20. T Tokenomics This concept does not take blockchain beyond crypto-currencies, but rather it expands the idea of crypto-currencies beyond money the way we have known it. In a solid ecosystem a token becomes more than a means of transaction settlement (buy, pay, transfer, invoice, etc.), it is an attitude, a vote, a stake. For example, you can use tokens to vote for some initiative. If it gets enough votes in tokens, your contribution will be written off your account and used to finance the initiative. This is a basic case, of course, many more can be invented. What makes tokenomics attractive, is the blockchain and smart-contract technology behind. These ensure decentralization, security, fairness, privacy and transparency at the same time. V Virtual machine A VM is a blockchain core or engine that takes smart contracts compiled to a blockchain-specific bytecode and executes them (performs transactions). Between transactions smart contracts are stored in the blockchain with persistent data (i.e. the data that remains in the contract). TON VM is called TVM, Ethereum VM is EVM. You can find detailed specification of each in the Internet. W Web 3.0 The original concept suggested as far back as in 2007 by Jason Calacanis implies a switch from Web 2.0's powerful services and tools to a whole new interaction and work culture. Then it was proposed to define Web 3.0 as the Internet interaction with the physical world. The latter idea, although criticized and over-used, resonates with our vision and with the decentralized economy concept. Indeed, blockchain has the potential to foster penetration of the Internet into the real world. Fintech services can be used to manage daily chores and bills, devices (IoT) and many more.","title":"The Moonspeak"},{"location":"5. Misc/Glossary/#the-moonspeak","text":"This brief set of terms and definitions is in no way exhaustive or final. It is based on personal experience with blockchain or related concepts and aims at making complex things a little more clear. What makes blockchain talk complicated, is that this rapidly evolving phenomenon pools together multiple concepts, methodologies and ideas from numerous areas and domains from math to behaviorist studies. Considered separately, each item may be clear and logical, but once pooled together and interwoven, they are not easy to define and describe in plain well-structured phrases. For example, explanation of the root term - Blockchain - can start from the basic notion of database, but just as well we can choose P2P networks as the starting place. Bringing both together within a single definition makes it long and more confusing. But we keep on trying. Hope you will have a good time reading it. Feedback and suggestions are welcome.","title":"The Moonspeak"},{"location":"5. Misc/Glossary/#b","text":"","title":"B"},{"location":"5. Misc/Glossary/#blockchain","text":"Blockchain is basically a database for storing transactions packed in blocks. Blockchain has some technical particularities that make it ideal for fintech services but quite awkward for general DB uses: data in blockchain cannot be changed (i.e. transactions are unchangeable), all data is linked to its owner, all data meets some mandatory rules (i.e. it is consistent) and, ta-da, its decentralized. Blockchains rely on peer-to-peer interaction and require no third-party regulation, control or coordination. To ensure fairness, there is consensus (validation procedures that enable mining) and encryption technologies. Another, broader, term for this type of databases is Distributed Ledger. Tip : for further reading we would suggesting articles about peer-to-peer networks, sharding, workchains, multi-chain models.","title":"Blockchain"},{"location":"5. Misc/Glossary/#c","text":"","title":"C"},{"location":"5. Misc/Glossary/#cold-wallet","text":"Cold wallet (aka hardware wallet) is a physical appliance (an nfc-card, a usb drive) where wallet private keys are stored. Cold wallets are considered more secure, as there is no way to hack them. Also, in some cases a cold wallet enables easier and faster access to transactions. For example, with an nfc-card you only have to hover it over the back side of your device to start transactions. No more mess with passwords and pin-codes.","title":"Cold Wallet"},{"location":"5. Misc/Glossary/#consensus","text":"Consensus is a protocol implemented within a blochchain to make sure that its nodes (engines that maintain the blockchain and may process transactions, depending on the architecture) agree on requirements to transactions to validate them. Interestingly, validation enabled crypto-currency mining, as newly mined coins are the reward for validating a transaction. With consensus in place, no centralized regulation is needed to prevent frauds. There are several popular consensus protocols: Proof of Work (PoW), Proof of Stake, Delegated Proof of Stake, etc. New consensus mechanisms evolve to reduce energy consumption associated with the PoW and optimize overall performance. Moreover, consensus without mining is being developed and researched.","title":"Consensus"},{"location":"5. Misc/Glossary/#crypto-currency","text":"Surprise, surprise, but crypto-currency is not necessarily blockchain and blockchain is not necessarily crypto-currency. Technically speaking, to generate crypto-currency one needs a distributed ledger meeting two core requirements: decentralized storage and encryption technology. Yet, blockchain remains the most popular, because it enables mining (i.e. generating new currency units) as a reward for transaction validation thus reducing commissions imposed on the parties. Tip : to dig deeper, you might want to research the related concepts: fiat money, token, burning, mining vs. minting, Byzantine Generals Problem, TenderMint.","title":"Crypto-currency"},{"location":"5. Misc/Glossary/#d","text":"","title":"D"},{"location":"5. Misc/Glossary/#dapp-decentralized-application","text":"In short, it is an application (usually fintech) with a blockchain smart-contract behind it to ensure fairness and decentralization. An extended definition though has to cover the infrastructure a bit. A standard app either operates locally (e.g. a single-player game) or uses some standard server-client architecture (e.g. a bank app). In blockchain, every Dapp is basically a smart contract that describes transactions and rules applied to them. Roughly speaking, each smart contract has a server side that is stored in the blockchain and executed by the virtual machine (back-end for machine-to-machine interaction) and the client-side that is available to a user and has a GUI for human to machine interaction (front-end). The two parts interact via messaging (basically, requests to the contract and its responses). The front-end part can be implement in many popular programming languages, most popular are .js and .ts, Python is on the rise.","title":"Dapp, Decentralized application"},{"location":"5. Misc/Glossary/#decentralized-economy","text":"In the real world anarchy turns out to be a disaster and everybody's business is known to be nobody's business. Communism failed and is dabbed a Utopian concept forever. In the digital world, however, blockchain is the game-changer when it comes to equal rights, fair play, data security, privacy, decentralization, democracy, transparency. You can have it all without any central authority, regulations and dictatorship. Hmm, is it as good as it sounds? Let's see. Booming peer to peer networks with consensus methods allow parties to safely and transparently carry out financial (or other) transactions without any regulator. Being just a technical thing, P2P solutions (in particular, blockchain) have no geographical, social, political or gender bias.","title":"Decentralized economy"},{"location":"5. Misc/Glossary/#n","text":"","title":"N"},{"location":"5. Misc/Glossary/#node","text":"Basically, Node is a blockchain server that has a working instance of a virtual machine (VM) and a set of relevant instruments that ensure VM interaction with clients (i.e. for example, with customer applications). Every blockchain platform has its own messaging standards and protocols, let alone VM's, so node architectures differ across platforms. What's more even within a single platform variations may exist, although all nodes have to be compatible within a platform. Visit TON Dev for its Node SE offer.","title":"Node"},{"location":"5. Misc/Glossary/#s","text":"","title":"S"},{"location":"5. Misc/Glossary/#smart-contract","text":"Smart contract is not a legal document, rather, it is a piece of code deployed in blockchain. This code contains an executable sequence of operations. Each operation manipulates some available data (e.g. an account balance), retrieves it and\\or changes it (e.g. transfers an amount). Each instance of smart contract execution is a blockchain transaction with block generation. Smart contract is the core part of each Dapp (roughly speaking, it is its back end). Smart contracts may interact with each other. There are several types of standard smart contracts that implement tokens. The most famous is ERC20.","title":"Smart contract"},{"location":"5. Misc/Glossary/#t","text":"","title":"T"},{"location":"5. Misc/Glossary/#tokenomics","text":"This concept does not take blockchain beyond crypto-currencies, but rather it expands the idea of crypto-currencies beyond money the way we have known it. In a solid ecosystem a token becomes more than a means of transaction settlement (buy, pay, transfer, invoice, etc.), it is an attitude, a vote, a stake. For example, you can use tokens to vote for some initiative. If it gets enough votes in tokens, your contribution will be written off your account and used to finance the initiative. This is a basic case, of course, many more can be invented. What makes tokenomics attractive, is the blockchain and smart-contract technology behind. These ensure decentralization, security, fairness, privacy and transparency at the same time.","title":"Tokenomics"},{"location":"5. Misc/Glossary/#v","text":"","title":"V"},{"location":"5. Misc/Glossary/#virtual-machine","text":"A VM is a blockchain core or engine that takes smart contracts compiled to a blockchain-specific bytecode and executes them (performs transactions). Between transactions smart contracts are stored in the blockchain with persistent data (i.e. the data that remains in the contract). TON VM is called TVM, Ethereum VM is EVM. You can find detailed specification of each in the Internet.","title":"Virtual machine"},{"location":"5. Misc/Glossary/#w","text":"","title":"W"},{"location":"5. Misc/Glossary/#web-30","text":"The original concept suggested as far back as in 2007 by Jason Calacanis implies a switch from Web 2.0's powerful services and tools to a whole new interaction and work culture. Then it was proposed to define Web 3.0 as the Internet interaction with the physical world. The latter idea, although criticized and over-used, resonates with our vision and with the decentralized economy concept. Indeed, blockchain has the potential to foster penetration of the Internet into the real world. Fintech services can be used to manage daily chores and bills, devices (IoT) and many more.","title":"Web 3.0"}]}